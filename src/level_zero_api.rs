/* automatically generated by rust-bindgen 0.57.0 */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = ""]
#[doc = " @brief compiler-independent type"]
pub type ze_bool_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of a driver instance"]
pub type ze_driver_handle_t = *mut _ze_driver_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's device object"]
pub type ze_device_handle_t = *mut _ze_device_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's context object"]
pub type ze_context_handle_t = *mut _ze_context_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's command queue object"]
pub type ze_command_queue_handle_t = *mut _ze_command_queue_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's command list object"]
pub type ze_command_list_handle_t = *mut _ze_command_list_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_fence_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's fence object"]
pub type ze_fence_handle_t = *mut _ze_fence_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_pool_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's event pool object"]
pub type ze_event_pool_handle_t = *mut _ze_event_pool_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's event object"]
pub type ze_event_handle_t = *mut _ze_event_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's image object"]
pub type ze_image_handle_t = *mut _ze_image_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's module object"]
pub type ze_module_handle_t = *mut _ze_module_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_build_log_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of module's build log object"]
pub type ze_module_build_log_handle_t = *mut _ze_module_build_log_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's kernel object"]
pub type ze_kernel_handle_t = *mut _ze_kernel_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_sampler_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's sampler object"]
pub type ze_sampler_handle_t = *mut _ze_sampler_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_physical_mem_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of physical memory object"]
pub type ze_physical_mem_handle_t = *mut _ze_physical_mem_handle_t;
#[doc = ""]
#[doc = " @brief IPC handle to a memory allocation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_ipc_mem_handle_t {
    #[doc = "< [out] Opaque data representing an IPC handle"]
    pub data: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout__ze_ipc_mem_handle_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_ipc_mem_handle_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ze_ipc_mem_handle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_ipc_mem_handle_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_ipc_mem_handle_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_ipc_mem_handle_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_ipc_mem_handle_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = ""]
#[doc = " @brief IPC handle to a memory allocation"]
pub type ze_ipc_mem_handle_t = _ze_ipc_mem_handle_t;
#[doc = ""]
#[doc = " @brief IPC handle to a event pool allocation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_ipc_event_pool_handle_t {
    #[doc = "< [out] Opaque data representing an IPC handle"]
    pub data: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout__ze_ipc_event_pool_handle_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_ipc_event_pool_handle_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ze_ipc_event_pool_handle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_ipc_event_pool_handle_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_ipc_event_pool_handle_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_ipc_event_pool_handle_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_ipc_event_pool_handle_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = ""]
#[doc = " @brief IPC handle to a event pool allocation"]
pub type ze_ipc_event_pool_handle_t = _ze_ipc_event_pool_handle_t;
impl _ze_result_t {
    #[doc = "< [Core] success"]
    pub const ZE_RESULT_SUCCESS: _ze_result_t = _ze_result_t(0);
}
impl _ze_result_t {
    #[doc = "< [Core] synchronization primitive not signaled"]
    pub const ZE_RESULT_NOT_READY: _ze_result_t = _ze_result_t(1);
}
impl _ze_result_t {
    #[doc = "< [Core] device hung, reset, was removed, or driver update occurred"]
    pub const ZE_RESULT_ERROR_DEVICE_LOST: _ze_result_t = _ze_result_t(1879048193);
}
impl _ze_result_t {
    #[doc = "< [Core] insufficient host memory to satisfy call"]
    pub const ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY: _ze_result_t = _ze_result_t(1879048194);
}
impl _ze_result_t {
    #[doc = "< [Core] insufficient device memory to satisfy call"]
    pub const ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY: _ze_result_t = _ze_result_t(1879048195);
}
impl _ze_result_t {
    #[doc = "< [Core] error occurred when building module, see build log for details"]
    pub const ZE_RESULT_ERROR_MODULE_BUILD_FAILURE: _ze_result_t = _ze_result_t(1879048196);
}
impl _ze_result_t {
    #[doc = "< [Core] error occurred when linking modules, see build log for details"]
    pub const ZE_RESULT_ERROR_MODULE_LINK_FAILURE: _ze_result_t = _ze_result_t(1879048197);
}
impl _ze_result_t {
    #[doc = "< [Sysman] access denied due to permission level"]
    pub const ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS: _ze_result_t = _ze_result_t(1879113728);
}
impl _ze_result_t {
    #[doc = "< [Sysman] resource already in use and simultaneous access not allowed"]
    #[doc = "< or resource was removed"]
    pub const ZE_RESULT_ERROR_NOT_AVAILABLE: _ze_result_t = _ze_result_t(1879113729);
}
impl _ze_result_t {
    #[doc = "< [Tools] external required dependency is unavailable or missing"]
    pub const ZE_RESULT_ERROR_DEPENDENCY_UNAVAILABLE: _ze_result_t = _ze_result_t(1879179264);
}
impl _ze_result_t {
    #[doc = "< [Validation] driver is not initialized"]
    pub const ZE_RESULT_ERROR_UNINITIALIZED: _ze_result_t = _ze_result_t(2013265921);
}
impl _ze_result_t {
    #[doc = "< [Validation] generic error code for unsupported versions"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_VERSION: _ze_result_t = _ze_result_t(2013265922);
}
impl _ze_result_t {
    #[doc = "< [Validation] generic error code for unsupported features"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_FEATURE: _ze_result_t = _ze_result_t(2013265923);
}
impl _ze_result_t {
    #[doc = "< [Validation] generic error code for invalid arguments"]
    pub const ZE_RESULT_ERROR_INVALID_ARGUMENT: _ze_result_t = _ze_result_t(2013265924);
}
impl _ze_result_t {
    #[doc = "< [Validation] handle argument is not valid"]
    pub const ZE_RESULT_ERROR_INVALID_NULL_HANDLE: _ze_result_t = _ze_result_t(2013265925);
}
impl _ze_result_t {
    #[doc = "< [Validation] object pointed to by handle still in-use by device"]
    pub const ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE: _ze_result_t = _ze_result_t(2013265926);
}
impl _ze_result_t {
    #[doc = "< [Validation] pointer argument may not be nullptr"]
    pub const ZE_RESULT_ERROR_INVALID_NULL_POINTER: _ze_result_t = _ze_result_t(2013265927);
}
impl _ze_result_t {
    #[doc = "< [Validation] size argument is invalid (e.g., must not be zero)"]
    pub const ZE_RESULT_ERROR_INVALID_SIZE: _ze_result_t = _ze_result_t(2013265928);
}
impl _ze_result_t {
    #[doc = "< [Validation] size argument is not supported by the device (e.g., too"]
    #[doc = "< large)"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_SIZE: _ze_result_t = _ze_result_t(2013265929);
}
impl _ze_result_t {
    #[doc = "< [Validation] alignment argument is not supported by the device (e.g.,"]
    #[doc = "< too small)"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT: _ze_result_t = _ze_result_t(2013265930);
}
impl _ze_result_t {
    #[doc = "< [Validation] synchronization object in invalid state"]
    pub const ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT: _ze_result_t =
        _ze_result_t(2013265931);
}
impl _ze_result_t {
    #[doc = "< [Validation] enumerator argument is not valid"]
    pub const ZE_RESULT_ERROR_INVALID_ENUMERATION: _ze_result_t = _ze_result_t(2013265932);
}
impl _ze_result_t {
    #[doc = "< [Validation] enumerator argument is not supported by the device"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_ENUMERATION: _ze_result_t = _ze_result_t(2013265933);
}
impl _ze_result_t {
    #[doc = "< [Validation] image format is not supported by the device"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT: _ze_result_t = _ze_result_t(2013265934);
}
impl _ze_result_t {
    #[doc = "< [Validation] native binary is not supported by the device"]
    pub const ZE_RESULT_ERROR_INVALID_NATIVE_BINARY: _ze_result_t = _ze_result_t(2013265935);
}
impl _ze_result_t {
    #[doc = "< [Validation] global variable is not found in the module"]
    pub const ZE_RESULT_ERROR_INVALID_GLOBAL_NAME: _ze_result_t = _ze_result_t(2013265936);
}
impl _ze_result_t {
    #[doc = "< [Validation] kernel name is not found in the module"]
    pub const ZE_RESULT_ERROR_INVALID_KERNEL_NAME: _ze_result_t = _ze_result_t(2013265937);
}
impl _ze_result_t {
    #[doc = "< [Validation] function name is not found in the module"]
    pub const ZE_RESULT_ERROR_INVALID_FUNCTION_NAME: _ze_result_t = _ze_result_t(2013265938);
}
impl _ze_result_t {
    #[doc = "< [Validation] group size dimension is not valid for the kernel or"]
    #[doc = "< device"]
    pub const ZE_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION: _ze_result_t = _ze_result_t(2013265939);
}
impl _ze_result_t {
    #[doc = "< [Validation] global width dimension is not valid for the kernel or"]
    #[doc = "< device"]
    pub const ZE_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION: _ze_result_t =
        _ze_result_t(2013265940);
}
impl _ze_result_t {
    #[doc = "< [Validation] kernel argument index is not valid for kernel"]
    pub const ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX: _ze_result_t =
        _ze_result_t(2013265941);
}
impl _ze_result_t {
    #[doc = "< [Validation] kernel argument size does not match kernel"]
    pub const ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE: _ze_result_t = _ze_result_t(2013265942);
}
impl _ze_result_t {
    #[doc = "< [Validation] value of kernel attribute is not valid for the kernel or"]
    #[doc = "< device"]
    pub const ZE_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE: _ze_result_t =
        _ze_result_t(2013265943);
}
impl _ze_result_t {
    #[doc = "< [Validation] module with imports needs to be linked before kernels can"]
    #[doc = "< be created from it."]
    pub const ZE_RESULT_ERROR_INVALID_MODULE_UNLINKED: _ze_result_t = _ze_result_t(2013265944);
}
impl _ze_result_t {
    #[doc = "< [Validation] command list type does not match command queue type"]
    pub const ZE_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE: _ze_result_t = _ze_result_t(2013265945);
}
impl _ze_result_t {
    #[doc = "< [Validation] copy operations do not support overlapping regions of"]
    #[doc = "< memory"]
    pub const ZE_RESULT_ERROR_OVERLAPPING_REGIONS: _ze_result_t = _ze_result_t(2013265946);
}
impl _ze_result_t {
    #[doc = "< [Core] unknown or internal error"]
    pub const ZE_RESULT_ERROR_UNKNOWN: _ze_result_t = _ze_result_t(2147483646);
}
impl _ze_result_t {
    pub const ZE_RESULT_FORCE_UINT32: _ze_result_t = _ze_result_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Defines Return/Error codes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
#[must_use]
pub struct _ze_result_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Defines Return/Error codes"]
pub use self::_ze_result_t as ze_result_t;
impl _ze_structure_type_t {
    #[doc = "< ::ze_driver_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES: _ze_structure_type_t = _ze_structure_type_t(1);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_driver_ipc_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(2);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES: _ze_structure_type_t = _ze_structure_type_t(3);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_compute_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_COMPUTE_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(4);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_module_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_MODULE_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(5);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_command_queue_group_properties_t"]
    pub const ZE_STRUCTURE_TYPE_COMMAND_QUEUE_GROUP_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(6);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_memory_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_MEMORY_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(7);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_memory_access_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_MEMORY_ACCESS_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(8);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_cache_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_CACHE_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(9);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_image_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_IMAGE_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(10);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_p2p_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_P2P_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(11);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_external_memory_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_EXTERNAL_MEMORY_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(12);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_context_desc_t"]
    pub const ZE_STRUCTURE_TYPE_CONTEXT_DESC: _ze_structure_type_t = _ze_structure_type_t(13);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_command_queue_desc_t"]
    pub const ZE_STRUCTURE_TYPE_COMMAND_QUEUE_DESC: _ze_structure_type_t = _ze_structure_type_t(14);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_command_list_desc_t"]
    pub const ZE_STRUCTURE_TYPE_COMMAND_LIST_DESC: _ze_structure_type_t = _ze_structure_type_t(15);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_event_pool_desc_t"]
    pub const ZE_STRUCTURE_TYPE_EVENT_POOL_DESC: _ze_structure_type_t = _ze_structure_type_t(16);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_event_desc_t"]
    pub const ZE_STRUCTURE_TYPE_EVENT_DESC: _ze_structure_type_t = _ze_structure_type_t(17);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_fence_desc_t"]
    pub const ZE_STRUCTURE_TYPE_FENCE_DESC: _ze_structure_type_t = _ze_structure_type_t(18);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_image_desc_t"]
    pub const ZE_STRUCTURE_TYPE_IMAGE_DESC: _ze_structure_type_t = _ze_structure_type_t(19);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_image_properties_t"]
    pub const ZE_STRUCTURE_TYPE_IMAGE_PROPERTIES: _ze_structure_type_t = _ze_structure_type_t(20);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_mem_alloc_desc_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC: _ze_structure_type_t =
        _ze_structure_type_t(21);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_host_mem_alloc_desc_t"]
    pub const ZE_STRUCTURE_TYPE_HOST_MEM_ALLOC_DESC: _ze_structure_type_t =
        _ze_structure_type_t(22);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_memory_allocation_properties_t"]
    pub const ZE_STRUCTURE_TYPE_MEMORY_ALLOCATION_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(23);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_external_memory_export_desc_t"]
    pub const ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_DESC: _ze_structure_type_t =
        _ze_structure_type_t(24);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_external_memory_import_fd_t"]
    pub const ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_FD: _ze_structure_type_t =
        _ze_structure_type_t(25);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_external_memory_export_fd_t"]
    pub const ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_FD: _ze_structure_type_t =
        _ze_structure_type_t(26);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_module_desc_t"]
    pub const ZE_STRUCTURE_TYPE_MODULE_DESC: _ze_structure_type_t = _ze_structure_type_t(27);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_module_properties_t"]
    pub const ZE_STRUCTURE_TYPE_MODULE_PROPERTIES: _ze_structure_type_t = _ze_structure_type_t(28);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_kernel_desc_t"]
    pub const ZE_STRUCTURE_TYPE_KERNEL_DESC: _ze_structure_type_t = _ze_structure_type_t(29);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_kernel_properties_t"]
    pub const ZE_STRUCTURE_TYPE_KERNEL_PROPERTIES: _ze_structure_type_t = _ze_structure_type_t(30);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_sampler_desc_t"]
    pub const ZE_STRUCTURE_TYPE_SAMPLER_DESC: _ze_structure_type_t = _ze_structure_type_t(31);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_physical_mem_desc_t"]
    pub const ZE_STRUCTURE_TYPE_PHYSICAL_MEM_DESC: _ze_structure_type_t = _ze_structure_type_t(32);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_raytracing_ext_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_RAYTRACING_EXT_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(65537);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_raytracing_mem_alloc_ext_desc_t"]
    pub const ZE_STRUCTURE_TYPE_RAYTRACING_MEM_ALLOC_EXT_DESC: _ze_structure_type_t =
        _ze_structure_type_t(65538);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_float_atomic_ext_properties_t"]
    pub const ZE_STRUCTURE_TYPE_FLOAT_ATOMIC_EXT_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(65539);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_relaxed_allocation_limits_exp_desc_t"]
    pub const ZE_STRUCTURE_TYPE_RELAXED_ALLOCATION_LIMITS_EXP_DESC: _ze_structure_type_t =
        _ze_structure_type_t(131073);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_module_program_exp_desc_t"]
    pub const ZE_STRUCTURE_TYPE_MODULE_PROGRAM_EXP_DESC: _ze_structure_type_t =
        _ze_structure_type_t(131074);
}
impl _ze_structure_type_t {
    pub const ZE_STRUCTURE_TYPE_FORCE_UINT32: _ze_structure_type_t =
        _ze_structure_type_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Defines structure types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_structure_type_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Defines structure types"]
pub use self::_ze_structure_type_t as ze_structure_type_t;
impl _ze_external_memory_type_flags_t {
    #[doc = "< an opaque POSIX file descriptor handle"]
    pub const ZE_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_FD: _ze_external_memory_type_flags_t =
        _ze_external_memory_type_flags_t(1);
}
impl _ze_external_memory_type_flags_t {
    #[doc = "< a file descriptor handle for a Linux dma_buf"]
    pub const ZE_EXTERNAL_MEMORY_TYPE_FLAG_DMA_BUF: _ze_external_memory_type_flags_t =
        _ze_external_memory_type_flags_t(2);
}
impl _ze_external_memory_type_flags_t {
    pub const ZE_EXTERNAL_MEMORY_TYPE_FLAG_FORCE_UINT32: _ze_external_memory_type_flags_t =
        _ze_external_memory_type_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_external_memory_type_flags_t> for _ze_external_memory_type_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_external_memory_type_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_external_memory_type_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_external_memory_type_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_external_memory_type_flags_t> for _ze_external_memory_type_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_external_memory_type_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_external_memory_type_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_external_memory_type_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief External memory type flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_external_memory_type_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief External memory type flags"]
pub use self::_ze_external_memory_type_flags_t as ze_external_memory_type_flags_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_driver_uuid_t"]
pub type ze_driver_uuid_t = _ze_driver_uuid_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_driver_properties_t"]
pub type ze_driver_properties_t = _ze_driver_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_driver_ipc_properties_t"]
pub type ze_driver_ipc_properties_t = _ze_driver_ipc_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_driver_extension_properties_t"]
pub type ze_driver_extension_properties_t = _ze_driver_extension_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_uuid_t"]
pub type ze_device_uuid_t = _ze_device_uuid_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_properties_t"]
pub type ze_device_properties_t = _ze_device_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_compute_properties_t"]
pub type ze_device_compute_properties_t = _ze_device_compute_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_native_kernel_uuid_t"]
pub type ze_native_kernel_uuid_t = _ze_native_kernel_uuid_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_module_properties_t"]
pub type ze_device_module_properties_t = _ze_device_module_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_command_queue_group_properties_t"]
pub type ze_command_queue_group_properties_t = _ze_command_queue_group_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_memory_properties_t"]
pub type ze_device_memory_properties_t = _ze_device_memory_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_memory_access_properties_t"]
pub type ze_device_memory_access_properties_t = _ze_device_memory_access_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_cache_properties_t"]
pub type ze_device_cache_properties_t = _ze_device_cache_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_image_properties_t"]
pub type ze_device_image_properties_t = _ze_device_image_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_external_memory_properties_t"]
pub type ze_device_external_memory_properties_t = _ze_device_external_memory_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_p2p_properties_t"]
pub type ze_device_p2p_properties_t = _ze_device_p2p_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_context_desc_t"]
pub type ze_context_desc_t = _ze_context_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_command_queue_desc_t"]
pub type ze_command_queue_desc_t = _ze_command_queue_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_command_list_desc_t"]
pub type ze_command_list_desc_t = _ze_command_list_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_copy_region_t"]
pub type ze_copy_region_t = _ze_copy_region_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_region_t"]
pub type ze_image_region_t = _ze_image_region_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_event_pool_desc_t"]
pub type ze_event_pool_desc_t = _ze_event_pool_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_event_desc_t"]
pub type ze_event_desc_t = _ze_event_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_timestamp_data_t"]
pub type ze_kernel_timestamp_data_t = _ze_kernel_timestamp_data_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_timestamp_result_t"]
pub type ze_kernel_timestamp_result_t = _ze_kernel_timestamp_result_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_fence_desc_t"]
pub type ze_fence_desc_t = _ze_fence_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_format_t"]
pub type ze_image_format_t = _ze_image_format_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_desc_t"]
pub type ze_image_desc_t = _ze_image_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_properties_t"]
pub type ze_image_properties_t = _ze_image_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_mem_alloc_desc_t"]
pub type ze_device_mem_alloc_desc_t = _ze_device_mem_alloc_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_host_mem_alloc_desc_t"]
pub type ze_host_mem_alloc_desc_t = _ze_host_mem_alloc_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_memory_allocation_properties_t"]
pub type ze_memory_allocation_properties_t = _ze_memory_allocation_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_module_constants_t"]
pub type ze_module_constants_t = _ze_module_constants_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_module_desc_t"]
pub type ze_module_desc_t = _ze_module_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_module_properties_t"]
pub type ze_module_properties_t = _ze_module_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_desc_t"]
pub type ze_kernel_desc_t = _ze_kernel_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_uuid_t"]
pub type ze_kernel_uuid_t = _ze_kernel_uuid_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_properties_t"]
pub type ze_kernel_properties_t = _ze_kernel_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_group_count_t"]
pub type ze_group_count_t = _ze_group_count_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_sampler_desc_t"]
pub type ze_sampler_desc_t = _ze_sampler_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_physical_mem_desc_t"]
pub type ze_physical_mem_desc_t = _ze_physical_mem_desc_t;
impl _ze_init_flags_t {
    #[doc = "< only initialize GPU drivers"]
    pub const ZE_INIT_FLAG_GPU_ONLY: _ze_init_flags_t = _ze_init_flags_t(1);
}
impl _ze_init_flags_t {
    pub const ZE_INIT_FLAG_FORCE_UINT32: _ze_init_flags_t = _ze_init_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_init_flags_t> for _ze_init_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_init_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_init_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_init_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_init_flags_t> for _ze_init_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_init_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_init_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_init_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported initialization flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_init_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported initialization flags"]
pub use self::_ze_init_flags_t as ze_init_flags_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Initialize the 'oneAPI' driver(s)"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must call this function before calling any other"]
    #[doc = "       function."]
    #[doc = "     - If this function is not called then all other functions will return"]
    #[doc = "       ::ZE_RESULT_ERROR_UNINITIALIZED."]
    #[doc = "     - Only one instance of each driver will be initialized per process."]
    #[doc = "     - The application may call this function multiple times with different"]
    #[doc = "       flags or environment variables enabled."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe for scenarios"]
    #[doc = "       where multiple libraries may initialize the driver(s) simultaneously."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    pub fn zeInit(flags: ze_init_flags_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves driver instances"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - A driver represents a collection of physical devices."]
    #[doc = "     - Multiple calls to this function will return identical driver handles,"]
    #[doc = "       in the same order."]
    #[doc = "     - The application may pass nullptr for pDrivers when only querying the"]
    #[doc = "       number of drivers."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetPlatformIDs"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDriverGet(pCount: *mut u32, phDrivers: *mut ze_driver_handle_t) -> ze_result_t;
}
impl _ze_api_version_t {
    #[doc = "< version 1.0"]
    pub const ZE_API_VERSION_1_0: _ze_api_version_t = _ze_api_version_t(65536);
}
impl _ze_api_version_t {
    #[doc = "< version 1.1"]
    pub const ZE_API_VERSION_1_1: _ze_api_version_t = _ze_api_version_t(65537);
}
impl _ze_api_version_t {
    #[doc = "< latest known version"]
    pub const ZE_API_VERSION_CURRENT: _ze_api_version_t = _ze_api_version_t(65537);
}
impl _ze_api_version_t {
    pub const ZE_API_VERSION_FORCE_UINT32: _ze_api_version_t = _ze_api_version_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported API versions"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - API versions contain major and minor attributes, use"]
#[doc = "       ::ZE_MAJOR_VERSION and ::ZE_MINOR_VERSION"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_api_version_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported API versions"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - API versions contain major and minor attributes, use"]
#[doc = "       ::ZE_MAJOR_VERSION and ::ZE_MINOR_VERSION"]
pub use self::_ze_api_version_t as ze_api_version_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Returns the API version supported by the specified driver"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == version`"]
    pub fn zeDriverGetApiVersion(
        hDriver: ze_driver_handle_t,
        version: *mut ze_api_version_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Driver universal unique id (UUID)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_uuid_t {
    #[doc = "< [out] opaque data representing a driver UUID"]
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__ze_driver_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_driver_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_driver_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_uuid_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_uuid_t),
            "::",
            stringify!(id)
        )
    );
}
#[doc = ""]
#[doc = " @brief Driver properties queried using ::zeDriverGetProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] universal unique identifier."]
    pub uuid: ze_driver_uuid_t,
    #[doc = "< [out] driver version"]
    #[doc = "< The driver version is a non-zero, monotonically increasing value where"]
    #[doc = "< higher values always indicate a more recent version."]
    pub driverVersion: u32,
}
#[test]
fn bindgen_test_layout__ze_driver_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_properties_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_driver_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_driver_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_properties_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_properties_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_properties_t>())).uuid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_properties_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_properties_t>())).driverVersion as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_properties_t),
            "::",
            stringify!(driverVersion)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves properties of the driver."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clGetPlatformInfo**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pDriverProperties`"]
    pub fn zeDriverGetProperties(
        hDriver: ze_driver_handle_t,
        pDriverProperties: *mut ze_driver_properties_t,
    ) -> ze_result_t;
}
impl _ze_ipc_property_flags_t {
    #[doc = "< Supports passing memory allocations between processes. See"]
    #[doc = "< ::zeMemGetIpcHandle."]
    pub const ZE_IPC_PROPERTY_FLAG_MEMORY: _ze_ipc_property_flags_t = _ze_ipc_property_flags_t(1);
}
impl _ze_ipc_property_flags_t {
    #[doc = "< Supports passing event pools between processes. See"]
    #[doc = "< ::zeEventPoolGetIpcHandle."]
    pub const ZE_IPC_PROPERTY_FLAG_EVENT_POOL: _ze_ipc_property_flags_t =
        _ze_ipc_property_flags_t(2);
}
impl _ze_ipc_property_flags_t {
    pub const ZE_IPC_PROPERTY_FLAG_FORCE_UINT32: _ze_ipc_property_flags_t =
        _ze_ipc_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_ipc_property_flags_t> for _ze_ipc_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_ipc_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_ipc_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_ipc_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_ipc_property_flags_t> for _ze_ipc_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_ipc_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_ipc_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_ipc_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported IPC property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_ipc_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported IPC property flags"]
pub use self::_ze_ipc_property_flags_t as ze_ipc_property_flags_t;
#[doc = ""]
#[doc = " @brief IPC properties queried using ::zeDriverGetIpcProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_ipc_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of ::ze_ipc_property_flags_t"]
    pub flags: ze_ipc_property_flags_t,
}
#[test]
fn bindgen_test_layout__ze_driver_ipc_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_ipc_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_driver_ipc_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_ipc_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_driver_ipc_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_ipc_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_ipc_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_ipc_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_ipc_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_ipc_properties_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_ipc_properties_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves IPC attributes of the driver"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pIpcProperties`"]
    pub fn zeDriverGetIpcProperties(
        hDriver: ze_driver_handle_t,
        pIpcProperties: *mut ze_driver_ipc_properties_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Extension properties queried using ::zeDriverGetExtensionProperties"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_driver_extension_properties_t {
    #[doc = "< [out] extension name"]
    pub name: [::std::os::raw::c_char; 256usize],
    #[doc = "< [out] extension version using ::ZE_MAKE_VERSION"]
    pub version: u32,
}
#[test]
fn bindgen_test_layout__ze_driver_extension_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_extension_properties_t>(),
        260usize,
        concat!("Size of: ", stringify!(_ze_driver_extension_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_extension_properties_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_driver_extension_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_extension_properties_t>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_extension_properties_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_extension_properties_t>())).version as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_extension_properties_t),
            "::",
            stringify!(version)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves extension properties"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkEnumerateInstanceExtensionProperties**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDriverGetExtensionProperties(
        hDriver: ze_driver_handle_t,
        pCount: *mut u32,
        pExtensionProperties: *mut ze_driver_extension_properties_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves function pointer for vendor-specific or experimental"]
    #[doc = "        extensions"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == name`"]
    #[doc = "         + `nullptr == ppFunctionAddress`"]
    pub fn zeDriverGetExtensionFunctionAddress(
        hDriver: ze_driver_handle_t,
        name: *const ::std::os::raw::c_char,
        ppFunctionAddress: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves devices within a driver"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Multiple calls to this function will return identical device handles,"]
    #[doc = "       in the same order."]
    #[doc = "     - The number and order of handles returned from this function is"]
    #[doc = "       affected by the ::ZE_AFFINITY_MASK and ::ZE_ENABLE_PCI_ID_DEVICE_ORDER"]
    #[doc = "       environment variables."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGet(
        hDriver: ze_driver_handle_t,
        pCount: *mut u32,
        phDevices: *mut ze_device_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves a sub-device from a device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Multiple calls to this function will return identical device handles,"]
    #[doc = "       in the same order."]
    #[doc = "     - The number of handles returned from this function is affected by the"]
    #[doc = "       ::ZE_AFFINITY_MASK environment variable."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clCreateSubDevices"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGetSubDevices(
        hDevice: ze_device_handle_t,
        pCount: *mut u32,
        phSubdevices: *mut ze_device_handle_t,
    ) -> ze_result_t;
}
impl _ze_device_type_t {
    #[doc = "< Graphics Processing Unit"]
    pub const ZE_DEVICE_TYPE_GPU: _ze_device_type_t = _ze_device_type_t(1);
}
impl _ze_device_type_t {
    #[doc = "< Central Processing Unit"]
    pub const ZE_DEVICE_TYPE_CPU: _ze_device_type_t = _ze_device_type_t(2);
}
impl _ze_device_type_t {
    #[doc = "< Field Programmable Gate Array"]
    pub const ZE_DEVICE_TYPE_FPGA: _ze_device_type_t = _ze_device_type_t(3);
}
impl _ze_device_type_t {
    #[doc = "< Memory Copy Accelerator"]
    pub const ZE_DEVICE_TYPE_MCA: _ze_device_type_t = _ze_device_type_t(4);
}
impl _ze_device_type_t {
    pub const ZE_DEVICE_TYPE_FORCE_UINT32: _ze_device_type_t = _ze_device_type_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported device types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_type_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported device types"]
pub use self::_ze_device_type_t as ze_device_type_t;
#[doc = ""]
#[doc = " @brief Device universal unique id (UUID)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_uuid_t {
    #[doc = "< [out] opaque data representing a device UUID"]
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__ze_device_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_device_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_device_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_uuid_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_uuid_t),
            "::",
            stringify!(id)
        )
    );
}
impl _ze_device_property_flags_t {
    #[doc = "< Device is integrated with the Host."]
    pub const ZE_DEVICE_PROPERTY_FLAG_INTEGRATED: _ze_device_property_flags_t =
        _ze_device_property_flags_t(1);
}
impl _ze_device_property_flags_t {
    #[doc = "< Device handle used for query represents a sub-device."]
    pub const ZE_DEVICE_PROPERTY_FLAG_SUBDEVICE: _ze_device_property_flags_t =
        _ze_device_property_flags_t(2);
}
impl _ze_device_property_flags_t {
    #[doc = "< Device supports error correction memory access."]
    pub const ZE_DEVICE_PROPERTY_FLAG_ECC: _ze_device_property_flags_t =
        _ze_device_property_flags_t(4);
}
impl _ze_device_property_flags_t {
    #[doc = "< Device supports on-demand page-faulting."]
    pub const ZE_DEVICE_PROPERTY_FLAG_ONDEMANDPAGING: _ze_device_property_flags_t =
        _ze_device_property_flags_t(8);
}
impl _ze_device_property_flags_t {
    pub const ZE_DEVICE_PROPERTY_FLAG_FORCE_UINT32: _ze_device_property_flags_t =
        _ze_device_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_property_flags_t> for _ze_device_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_property_flags_t> for _ze_device_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported device property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported device property flags"]
pub use self::_ze_device_property_flags_t as ze_device_property_flags_t;
#[doc = ""]
#[doc = " @brief Device properties queried using ::zeDeviceGetProperties"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_device_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] generic device type"]
    pub type_: ze_device_type_t,
    #[doc = "< [out] vendor id from PCI configuration"]
    pub vendorId: u32,
    #[doc = "< [out] device id from PCI configuration"]
    pub deviceId: u32,
    #[doc = "< [out] 0 (none) or a valid combination of ::ze_device_property_flags_t"]
    pub flags: ze_device_property_flags_t,
    #[doc = "< [out] sub-device id. Only valid if ::ZE_DEVICE_PROPERTY_FLAG_SUBDEVICE"]
    #[doc = "< is set."]
    pub subdeviceId: u32,
    #[doc = "< [out] Clock rate for device core."]
    pub coreClockRate: u32,
    #[doc = "< [out] Maximum memory allocation size."]
    pub maxMemAllocSize: u64,
    #[doc = "< [out] Maximum number of logical hardware contexts."]
    pub maxHardwareContexts: u32,
    #[doc = "< [out] Maximum priority for command queues. Higher value is higher"]
    #[doc = "< priority."]
    pub maxCommandQueuePriority: u32,
    #[doc = "< [out] Number of threads per EU."]
    pub numThreadsPerEU: u32,
    #[doc = "< [out] The physical EU simd width."]
    pub physicalEUSimdWidth: u32,
    #[doc = "< [out] Number of EUs per sub-slice."]
    pub numEUsPerSubslice: u32,
    #[doc = "< [out] Number of sub-slices per slice."]
    pub numSubslicesPerSlice: u32,
    #[doc = "< [out] Number of slices."]
    pub numSlices: u32,
    #[doc = "< [out] Returns the resolution of device timer in cycles per second used"]
    #[doc = "< for profiling, timestamps, etc."]
    pub timerResolution: u64,
    #[doc = "< [out] Returns the number of valid bits in the timestamp value."]
    pub timestampValidBits: u32,
    #[doc = "< [out] Returns the number of valid bits in the kernel timestamp values"]
    pub kernelTimestampValidBits: u32,
    #[doc = "< [out] universal unique identifier. Note: Subdevices will have their"]
    #[doc = "< own uuid."]
    pub uuid: ze_device_uuid_t,
    #[doc = "< [out] Device name"]
    pub name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout__ze_device_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_properties_t>(),
        368usize,
        concat!("Size of: ", stringify!(_ze_device_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).vendorId as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(vendorId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).deviceId as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(deviceId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).subdeviceId as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(subdeviceId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).coreClockRate as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(coreClockRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).maxMemAllocSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(maxMemAllocSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).maxHardwareContexts as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(maxHardwareContexts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).maxCommandQueuePriority as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(maxCommandQueuePriority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numThreadsPerEU as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numThreadsPerEU)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).physicalEUSimdWidth as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(physicalEUSimdWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numEUsPerSubslice as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numEUsPerSubslice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numSubslicesPerSlice as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numSubslicesPerSlice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numSlices as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).timerResolution as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(timerResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).timestampValidBits as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(timestampValidBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).kernelTimestampValidBits as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(kernelTimestampValidBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).uuid as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).name as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pDeviceProperties`"]
    pub fn zeDeviceGetProperties(
        hDevice: ze_device_handle_t,
        pDeviceProperties: *mut ze_device_properties_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Device compute properties queried using ::zeDeviceGetComputeProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_compute_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Maximum items per compute group. (groupSizeX * groupSizeY *"]
    #[doc = "< groupSizeZ) <= maxTotalGroupSize"]
    pub maxTotalGroupSize: u32,
    #[doc = "< [out] Maximum items for X dimension in group"]
    pub maxGroupSizeX: u32,
    #[doc = "< [out] Maximum items for Y dimension in group"]
    pub maxGroupSizeY: u32,
    #[doc = "< [out] Maximum items for Z dimension in group"]
    pub maxGroupSizeZ: u32,
    #[doc = "< [out] Maximum groups that can be launched for x dimension"]
    pub maxGroupCountX: u32,
    #[doc = "< [out] Maximum groups that can be launched for y dimension"]
    pub maxGroupCountY: u32,
    #[doc = "< [out] Maximum groups that can be launched for z dimension"]
    pub maxGroupCountZ: u32,
    #[doc = "< [out] Maximum shared local memory per group."]
    pub maxSharedLocalMemory: u32,
    #[doc = "< [out] Number of subgroup sizes supported. This indicates number of"]
    #[doc = "< entries in subGroupSizes."]
    pub numSubGroupSizes: u32,
    #[doc = "< [out] Size group sizes supported."]
    pub subGroupSizes: [u32; 8usize],
}
#[test]
fn bindgen_test_layout__ze_device_compute_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_compute_properties_t>(),
        88usize,
        concat!("Size of: ", stringify!(_ze_device_compute_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_compute_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_compute_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxTotalGroupSize
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxTotalGroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupSizeX as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupSizeY as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupSizeZ as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupSizeZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupCountX as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupCountX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupCountY as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupCountY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupCountZ as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupCountZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxSharedLocalMemory
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxSharedLocalMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).numSubGroupSizes as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(numSubGroupSizes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).subGroupSizes as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(subGroupSizes)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves compute properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pComputeProperties`"]
    pub fn zeDeviceGetComputeProperties(
        hDevice: ze_device_handle_t,
        pComputeProperties: *mut ze_device_compute_properties_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Native kernel universal unique id (UUID)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_native_kernel_uuid_t {
    #[doc = "< [out] opaque data representing a native kernel UUID"]
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__ze_native_kernel_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_native_kernel_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_native_kernel_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_native_kernel_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_native_kernel_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_native_kernel_uuid_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_native_kernel_uuid_t),
            "::",
            stringify!(id)
        )
    );
}
impl _ze_device_module_flags_t {
    #[doc = "< Device supports 16-bit floating-point operations"]
    pub const ZE_DEVICE_MODULE_FLAG_FP16: _ze_device_module_flags_t = _ze_device_module_flags_t(1);
}
impl _ze_device_module_flags_t {
    #[doc = "< Device supports 64-bit floating-point operations"]
    pub const ZE_DEVICE_MODULE_FLAG_FP64: _ze_device_module_flags_t = _ze_device_module_flags_t(2);
}
impl _ze_device_module_flags_t {
    #[doc = "< Device supports 64-bit atomic operations"]
    pub const ZE_DEVICE_MODULE_FLAG_INT64_ATOMICS: _ze_device_module_flags_t =
        _ze_device_module_flags_t(4);
}
impl _ze_device_module_flags_t {
    #[doc = "< Device supports four component dot product and accumulate operations"]
    pub const ZE_DEVICE_MODULE_FLAG_DP4A: _ze_device_module_flags_t = _ze_device_module_flags_t(8);
}
impl _ze_device_module_flags_t {
    pub const ZE_DEVICE_MODULE_FLAG_FORCE_UINT32: _ze_device_module_flags_t =
        _ze_device_module_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_module_flags_t> for _ze_device_module_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_module_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_module_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_module_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_module_flags_t> for _ze_device_module_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_module_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_module_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_module_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported device module flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_module_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported device module flags"]
pub use self::_ze_device_module_flags_t as ze_device_module_flags_t;
impl _ze_device_fp_flags_t {
    #[doc = "< Supports denorms"]
    pub const ZE_DEVICE_FP_FLAG_DENORM: _ze_device_fp_flags_t = _ze_device_fp_flags_t(1);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports INF and quiet NaNs"]
    pub const ZE_DEVICE_FP_FLAG_INF_NAN: _ze_device_fp_flags_t = _ze_device_fp_flags_t(2);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports rounding to nearest even rounding mode"]
    pub const ZE_DEVICE_FP_FLAG_ROUND_TO_NEAREST: _ze_device_fp_flags_t = _ze_device_fp_flags_t(4);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports rounding to zero."]
    pub const ZE_DEVICE_FP_FLAG_ROUND_TO_ZERO: _ze_device_fp_flags_t = _ze_device_fp_flags_t(8);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports rounding to both positive and negative INF."]
    pub const ZE_DEVICE_FP_FLAG_ROUND_TO_INF: _ze_device_fp_flags_t = _ze_device_fp_flags_t(16);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports IEEE754-2008 fused multiply-add."]
    pub const ZE_DEVICE_FP_FLAG_FMA: _ze_device_fp_flags_t = _ze_device_fp_flags_t(32);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports rounding as defined by IEEE754 for divide and sqrt"]
    #[doc = "< operations."]
    pub const ZE_DEVICE_FP_FLAG_ROUNDED_DIVIDE_SQRT: _ze_device_fp_flags_t =
        _ze_device_fp_flags_t(64);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Uses software implementation for basic floating-point operations."]
    pub const ZE_DEVICE_FP_FLAG_SOFT_FLOAT: _ze_device_fp_flags_t = _ze_device_fp_flags_t(128);
}
impl _ze_device_fp_flags_t {
    pub const ZE_DEVICE_FP_FLAG_FORCE_UINT32: _ze_device_fp_flags_t =
        _ze_device_fp_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_fp_flags_t> for _ze_device_fp_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_fp_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_fp_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_fp_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_fp_flags_t> for _ze_device_fp_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_fp_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_fp_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_fp_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported floating-Point capability flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_fp_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported floating-Point capability flags"]
pub use self::_ze_device_fp_flags_t as ze_device_fp_flags_t;
#[doc = ""]
#[doc = " @brief Device module properties queried using ::zeDeviceGetModuleProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_module_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Maximum supported SPIR-V version."]
    #[doc = "< Returns zero if SPIR-V is not supported."]
    #[doc = "< Contains major and minor attributes, use ::ZE_MAJOR_VERSION and ::ZE_MINOR_VERSION."]
    pub spirvVersionSupported: u32,
    #[doc = "< [out] 0 or a valid combination of ::ze_device_module_flags_t"]
    pub flags: ze_device_module_flags_t,
    #[doc = "< [out] Capabilities for half-precision floating-point operations."]
    #[doc = "< returns 0 (if ::ZE_DEVICE_MODULE_FLAG_FP16 is not set) or a"]
    #[doc = "< combination of ::ze_device_fp_flags_t."]
    pub fp16flags: ze_device_fp_flags_t,
    #[doc = "< [out] Capabilities for single-precision floating-point operations."]
    #[doc = "< returns a combination of ::ze_device_fp_flags_t."]
    pub fp32flags: ze_device_fp_flags_t,
    #[doc = "< [out] Capabilities for double-precision floating-point operations."]
    #[doc = "< returns 0 (if ::ZE_DEVICE_MODULE_FLAG_FP64 is not set) or a"]
    #[doc = "< combination of ::ze_device_fp_flags_t."]
    pub fp64flags: ze_device_fp_flags_t,
    #[doc = "< [out] Maximum kernel argument size that is supported."]
    pub maxArgumentsSize: u32,
    #[doc = "< [out] Maximum size of internal buffer that holds output of printf"]
    #[doc = "< calls from kernel."]
    pub printfBufferSize: u32,
    #[doc = "< [out] Compatibility UUID of supported native kernel."]
    #[doc = "< UUID may or may not be the same across driver release, devices, or"]
    #[doc = "< operating systems."]
    #[doc = "< Application is responsible for ensuring UUID matches before creating"]
    #[doc = "< module using"]
    #[doc = "< previously created native kernel."]
    pub nativeKernelSupported: ze_native_kernel_uuid_t,
}
#[test]
fn bindgen_test_layout__ze_device_module_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_module_properties_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ze_device_module_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_module_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_module_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).spirvVersionSupported
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(spirvVersionSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).flags as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).fp16flags as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(fp16flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).fp32flags as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(fp32flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).fp64flags as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(fp64flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).maxArgumentsSize as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(maxArgumentsSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).printfBufferSize as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(printfBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).nativeKernelSupported
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(nativeKernelSupported)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves module properties of the device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pModuleProperties`"]
    pub fn zeDeviceGetModuleProperties(
        hDevice: ze_device_handle_t,
        pModuleProperties: *mut ze_device_module_properties_t,
    ) -> ze_result_t;
}
impl _ze_command_queue_group_property_flags_t {
    #[doc = "< Command queue group supports enqueing compute commands."]
    pub const ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COMPUTE:
        _ze_command_queue_group_property_flags_t = _ze_command_queue_group_property_flags_t(1);
}
impl _ze_command_queue_group_property_flags_t {
    #[doc = "< Command queue group supports enqueing copy commands."]
    pub const ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COPY: _ze_command_queue_group_property_flags_t =
        _ze_command_queue_group_property_flags_t(2);
}
impl _ze_command_queue_group_property_flags_t {
    #[doc = "< Command queue group supports cooperative kernels."]
    #[doc = "< See ::zeCommandListAppendLaunchCooperativeKernel for more details."]
    pub const ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COOPERATIVE_KERNELS:
        _ze_command_queue_group_property_flags_t = _ze_command_queue_group_property_flags_t(4);
}
impl _ze_command_queue_group_property_flags_t {
    #[doc = "< Command queue groups supports metric queries."]
    pub const ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_METRICS:
        _ze_command_queue_group_property_flags_t = _ze_command_queue_group_property_flags_t(8);
}
impl _ze_command_queue_group_property_flags_t {
    pub const ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_FORCE_UINT32:
        _ze_command_queue_group_property_flags_t =
        _ze_command_queue_group_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_command_queue_group_property_flags_t>
    for _ze_command_queue_group_property_flags_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_command_queue_group_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_command_queue_group_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_command_queue_group_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_command_queue_group_property_flags_t>
    for _ze_command_queue_group_property_flags_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_command_queue_group_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_command_queue_group_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_command_queue_group_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported command queue group property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_command_queue_group_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported command queue group property flags"]
pub use self::_ze_command_queue_group_property_flags_t as ze_command_queue_group_property_flags_t;
#[doc = ""]
#[doc = " @brief Command queue group properties queried using"]
#[doc = "        ::zeDeviceGetCommandQueueGroupProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_group_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of"]
    #[doc = "< ::ze_command_queue_group_property_flags_t"]
    pub flags: ze_command_queue_group_property_flags_t,
    #[doc = "< [out] maximum `pattern_size` supported by command queue group."]
    #[doc = "< See ::zeCommandListAppendMemoryFill for more details."]
    pub maxMemoryFillPatternSize: usize,
    #[doc = "< [out] the number of physical engines within the group."]
    pub numQueues: u32,
}
#[test]
fn bindgen_test_layout__ze_command_queue_group_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_queue_group_properties_t>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_queue_group_properties_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_queue_group_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_queue_group_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_group_properties_t>())).stype as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_group_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_group_properties_t>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_group_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_group_properties_t>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_group_properties_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_group_properties_t>()))
                .maxMemoryFillPatternSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_group_properties_t),
            "::",
            stringify!(maxMemoryFillPatternSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_group_properties_t>())).numQueues as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_group_properties_t),
            "::",
            stringify!(numQueues)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves command queue group properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Properties are reported for each physical command queue type supported"]
    #[doc = "       by the device."]
    #[doc = "     - Multiple calls to this function will return properties in the same"]
    #[doc = "       order."]
    #[doc = "     - The order in which the properties are returned defines the command"]
    #[doc = "       queue group's ordinal."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkGetPhysicalDeviceQueueFamilyProperties**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGetCommandQueueGroupProperties(
        hDevice: ze_device_handle_t,
        pCount: *mut u32,
        pCommandQueueGroupProperties: *mut ze_command_queue_group_properties_t,
    ) -> ze_result_t;
}
impl _ze_device_memory_property_flags_t {
    #[doc = "< reserved for future use"]
    pub const ZE_DEVICE_MEMORY_PROPERTY_FLAG_TBD: _ze_device_memory_property_flags_t =
        _ze_device_memory_property_flags_t(1);
}
impl _ze_device_memory_property_flags_t {
    pub const ZE_DEVICE_MEMORY_PROPERTY_FLAG_FORCE_UINT32: _ze_device_memory_property_flags_t =
        _ze_device_memory_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_memory_property_flags_t> for _ze_device_memory_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_memory_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_memory_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_memory_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_memory_property_flags_t> for _ze_device_memory_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_memory_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_memory_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_memory_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported device memory property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_memory_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported device memory property flags"]
pub use self::_ze_device_memory_property_flags_t as ze_device_memory_property_flags_t;
#[doc = ""]
#[doc = " @brief Device local memory properties queried using"]
#[doc = "        ::zeDeviceGetMemoryProperties"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_device_memory_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of"]
    #[doc = "< ::ze_device_memory_property_flags_t"]
    pub flags: ze_device_memory_property_flags_t,
    #[doc = "< [out] Maximum clock rate for device memory."]
    pub maxClockRate: u32,
    #[doc = "< [out] Maximum bus width between device and memory."]
    pub maxBusWidth: u32,
    #[doc = "< [out] Total memory size in bytes that is available to the device."]
    pub totalSize: u64,
    #[doc = "< [out] Memory name"]
    pub name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout__ze_device_memory_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_memory_properties_t>(),
        296usize,
        concat!("Size of: ", stringify!(_ze_device_memory_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_memory_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_memory_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).maxClockRate as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(maxClockRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).maxBusWidth as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(maxBusWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).totalSize as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(totalSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).name as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves local memory properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Properties are reported for each physical memory type supported by the"]
    #[doc = "       device."]
    #[doc = "     - Multiple calls to this function will return properties in the same"]
    #[doc = "       order."]
    #[doc = "     - The order in which the properties are returned defines the device's"]
    #[doc = "       local memory ordinal."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGetMemoryProperties(
        hDevice: ze_device_handle_t,
        pCount: *mut u32,
        pMemProperties: *mut ze_device_memory_properties_t,
    ) -> ze_result_t;
}
impl _ze_memory_access_cap_flags_t {
    #[doc = "< Supports load/store access"]
    pub const ZE_MEMORY_ACCESS_CAP_FLAG_RW: _ze_memory_access_cap_flags_t =
        _ze_memory_access_cap_flags_t(1);
}
impl _ze_memory_access_cap_flags_t {
    #[doc = "< Supports atomic access"]
    pub const ZE_MEMORY_ACCESS_CAP_FLAG_ATOMIC: _ze_memory_access_cap_flags_t =
        _ze_memory_access_cap_flags_t(2);
}
impl _ze_memory_access_cap_flags_t {
    #[doc = "< Supports concurrent access"]
    pub const ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT: _ze_memory_access_cap_flags_t =
        _ze_memory_access_cap_flags_t(4);
}
impl _ze_memory_access_cap_flags_t {
    #[doc = "< Supports concurrent atomic access"]
    pub const ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT_ATOMIC: _ze_memory_access_cap_flags_t =
        _ze_memory_access_cap_flags_t(8);
}
impl _ze_memory_access_cap_flags_t {
    pub const ZE_MEMORY_ACCESS_CAP_FLAG_FORCE_UINT32: _ze_memory_access_cap_flags_t =
        _ze_memory_access_cap_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_memory_access_cap_flags_t> for _ze_memory_access_cap_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_memory_access_cap_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_memory_access_cap_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_memory_access_cap_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_memory_access_cap_flags_t> for _ze_memory_access_cap_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_memory_access_cap_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_memory_access_cap_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_memory_access_cap_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Memory access capability flags"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - Supported access capabilities for different types of memory"]
#[doc = "       allocations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_memory_access_cap_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Memory access capability flags"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - Supported access capabilities for different types of memory"]
#[doc = "       allocations"]
pub use self::_ze_memory_access_cap_flags_t as ze_memory_access_cap_flags_t;
#[doc = ""]
#[doc = " @brief Device memory access properties queried using"]
#[doc = "        ::zeDeviceGetMemoryAccessProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_memory_access_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] host memory capabilities."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_memory_access_cap_flags_t."]
    pub hostAllocCapabilities: ze_memory_access_cap_flags_t,
    #[doc = "< [out] device memory capabilities."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_memory_access_cap_flags_t."]
    pub deviceAllocCapabilities: ze_memory_access_cap_flags_t,
    #[doc = "< [out] shared, single-device memory capabilities."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_memory_access_cap_flags_t."]
    pub sharedSingleDeviceAllocCapabilities: ze_memory_access_cap_flags_t,
    #[doc = "< [out] shared, cross-device memory capabilities."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_memory_access_cap_flags_t."]
    pub sharedCrossDeviceAllocCapabilities: ze_memory_access_cap_flags_t,
    #[doc = "< [out] shared, system memory capabilities."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_memory_access_cap_flags_t."]
    pub sharedSystemAllocCapabilities: ze_memory_access_cap_flags_t,
}
#[test]
fn bindgen_test_layout__ze_device_memory_access_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_memory_access_properties_t>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_memory_access_properties_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_memory_access_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_memory_access_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>())).stype as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>())).hostAllocCapabilities
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(hostAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .deviceAllocCapabilities as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(deviceAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .sharedSingleDeviceAllocCapabilities as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(sharedSingleDeviceAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .sharedCrossDeviceAllocCapabilities as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(sharedCrossDeviceAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .sharedSystemAllocCapabilities as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(sharedSystemAllocCapabilities)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves memory access properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pMemAccessProperties`"]
    pub fn zeDeviceGetMemoryAccessProperties(
        hDevice: ze_device_handle_t,
        pMemAccessProperties: *mut ze_device_memory_access_properties_t,
    ) -> ze_result_t;
}
impl _ze_device_cache_property_flags_t {
    #[doc = "< Device support User Cache Control (i.e. SLM section vs Generic Cache)"]
    pub const ZE_DEVICE_CACHE_PROPERTY_FLAG_USER_CONTROL: _ze_device_cache_property_flags_t =
        _ze_device_cache_property_flags_t(1);
}
impl _ze_device_cache_property_flags_t {
    pub const ZE_DEVICE_CACHE_PROPERTY_FLAG_FORCE_UINT32: _ze_device_cache_property_flags_t =
        _ze_device_cache_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_cache_property_flags_t> for _ze_device_cache_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_cache_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_cache_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_cache_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_cache_property_flags_t> for _ze_device_cache_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_cache_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_cache_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_cache_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported cache control property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_cache_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported cache control property flags"]
pub use self::_ze_device_cache_property_flags_t as ze_device_cache_property_flags_t;
#[doc = ""]
#[doc = " @brief Device cache properties queried using ::zeDeviceGetCacheProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_cache_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of"]
    #[doc = "< ::ze_device_cache_property_flags_t"]
    pub flags: ze_device_cache_property_flags_t,
    #[doc = "< [out] Per-cache size, in bytes"]
    pub cacheSize: usize,
}
#[test]
fn bindgen_test_layout__ze_device_cache_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_cache_properties_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_device_cache_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_cache_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_cache_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).cacheSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(cacheSize)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves cache properties of the device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGetCacheProperties(
        hDevice: ze_device_handle_t,
        pCount: *mut u32,
        pCacheProperties: *mut ze_device_cache_properties_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Device image properties queried using ::zeDeviceGetImageProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_image_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Maximum image dimensions for 1D resources. if 0, then 1D images"]
    #[doc = "< are unsupported."]
    pub maxImageDims1D: u32,
    #[doc = "< [out] Maximum image dimensions for 2D resources. if 0, then 2D images"]
    #[doc = "< are unsupported."]
    pub maxImageDims2D: u32,
    #[doc = "< [out] Maximum image dimensions for 3D resources. if 0, then 3D images"]
    #[doc = "< are unsupported."]
    pub maxImageDims3D: u32,
    #[doc = "< [out] Maximum image buffer size in bytes. if 0, then buffer images are"]
    #[doc = "< unsupported."]
    pub maxImageBufferSize: u64,
    #[doc = "< [out] Maximum image array slices. if 0, then image arrays are"]
    #[doc = "< unsupported."]
    pub maxImageArraySlices: u32,
    #[doc = "< [out] Max samplers that can be used in kernel. if 0, then sampling is"]
    #[doc = "< unsupported."]
    pub maxSamplers: u32,
    #[doc = "< [out] Returns the maximum number of simultaneous image objects that"]
    #[doc = "< can be read from by a kernel. if 0, then reading images is"]
    #[doc = "< unsupported."]
    pub maxReadImageArgs: u32,
    #[doc = "< [out] Returns the maximum number of simultaneous image objects that"]
    #[doc = "< can be written to by a kernel. if 0, then writing images is"]
    #[doc = "< unsupported."]
    pub maxWriteImageArgs: u32,
}
#[test]
fn bindgen_test_layout__ze_device_image_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_image_properties_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ze_device_image_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_image_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_image_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageDims1D as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageDims1D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageDims2D as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageDims2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageDims3D as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageDims3D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageBufferSize as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageArraySlices
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageArraySlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxSamplers as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxSamplers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxReadImageArgs as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxReadImageArgs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxWriteImageArgs as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxWriteImageArgs)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves image properties of the device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - See ::zeImageGetProperties for format-specific capabilities."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pImageProperties`"]
    pub fn zeDeviceGetImageProperties(
        hDevice: ze_device_handle_t,
        pImageProperties: *mut ze_device_image_properties_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Device external memory import and export properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_external_memory_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Supported external memory import types for memory allocations."]
    pub memoryAllocationImportTypes: ze_external_memory_type_flags_t,
    #[doc = "< [out] Supported external memory export types for memory allocations."]
    pub memoryAllocationExportTypes: ze_external_memory_type_flags_t,
    #[doc = "< [out] Supported external memory import types for images."]
    pub imageImportTypes: ze_external_memory_type_flags_t,
    #[doc = "< [out] Supported external memory export types for images."]
    pub imageExportTypes: ze_external_memory_type_flags_t,
}
#[test]
fn bindgen_test_layout__ze_device_external_memory_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_external_memory_properties_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_external_memory_properties_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_external_memory_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_external_memory_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>())).stype as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>()))
                .memoryAllocationImportTypes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(memoryAllocationImportTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>()))
                .memoryAllocationExportTypes as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(memoryAllocationExportTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>())).imageImportTypes
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(imageImportTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>())).imageExportTypes
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(imageExportTypes)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves external memory import and export of the device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pExternalMemoryProperties`"]
    pub fn zeDeviceGetExternalMemoryProperties(
        hDevice: ze_device_handle_t,
        pExternalMemoryProperties: *mut ze_device_external_memory_properties_t,
    ) -> ze_result_t;
}
impl _ze_device_p2p_property_flags_t {
    #[doc = "< Device supports access between peer devices."]
    pub const ZE_DEVICE_P2P_PROPERTY_FLAG_ACCESS: _ze_device_p2p_property_flags_t =
        _ze_device_p2p_property_flags_t(1);
}
impl _ze_device_p2p_property_flags_t {
    #[doc = "< Device supports atomics between peer devices."]
    pub const ZE_DEVICE_P2P_PROPERTY_FLAG_ATOMICS: _ze_device_p2p_property_flags_t =
        _ze_device_p2p_property_flags_t(2);
}
impl _ze_device_p2p_property_flags_t {
    pub const ZE_DEVICE_P2P_PROPERTY_FLAG_FORCE_UINT32: _ze_device_p2p_property_flags_t =
        _ze_device_p2p_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_p2p_property_flags_t> for _ze_device_p2p_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_p2p_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_p2p_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_p2p_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_p2p_property_flags_t> for _ze_device_p2p_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_p2p_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_p2p_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_p2p_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported device peer-to-peer property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_p2p_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported device peer-to-peer property flags"]
pub use self::_ze_device_p2p_property_flags_t as ze_device_p2p_property_flags_t;
#[doc = ""]
#[doc = " @brief Device peer-to-peer properties queried using"]
#[doc = "        ::zeDeviceGetP2PProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_p2p_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of"]
    #[doc = "< ::ze_device_p2p_property_flags_t"]
    pub flags: ze_device_p2p_property_flags_t,
}
#[test]
fn bindgen_test_layout__ze_device_p2p_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_p2p_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_device_p2p_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_p2p_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_p2p_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_p2p_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_p2p_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_p2p_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_p2p_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_p2p_properties_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_p2p_properties_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves peer-to-peer properties between one device and a peer"]
    #[doc = "        devices"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hPeerDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pP2PProperties`"]
    pub fn zeDeviceGetP2PProperties(
        hDevice: ze_device_handle_t,
        hPeerDevice: ze_device_handle_t,
        pP2PProperties: *mut ze_device_p2p_properties_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries if one device can directly access peer device allocations"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Any device can access any other device within a node through a"]
    #[doc = "       scale-up fabric."]
    #[doc = "     - The following are conditions for CanAccessPeer query."]
    #[doc = "         + If both device and peer device are the same then return true."]
    #[doc = "         + If both sub-device and peer sub-device are the same then return"]
    #[doc = "           true."]
    #[doc = "         + If both are sub-devices and share the same parent device then"]
    #[doc = "           return true."]
    #[doc = "         + If both device and remote device are connected by a direct or"]
    #[doc = "           indirect scale-up fabric or over PCIe (same root complex or shared"]
    #[doc = "           PCIe switch) then true."]
    #[doc = "         + If both sub-device and remote parent device (and vice-versa) are"]
    #[doc = "           connected by a direct or indirect scale-up fabric or over PCIe"]
    #[doc = "           (same root complex or shared PCIe switch) then true."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hPeerDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == value`"]
    pub fn zeDeviceCanAccessPeer(
        hDevice: ze_device_handle_t,
        hPeerDevice: ze_device_handle_t,
        value: *mut ze_bool_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Returns current status of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Once a device is reset, this call will update the OS handle attached"]
    #[doc = "       to the device handle."]
    #[doc = "     - The application may call this function from simultaneous threads with"]
    #[doc = "       the same device handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "         + Device is available for use."]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "         + Device is lost; must be reset for use."]
    pub fn zeDeviceGetStatus(hDevice: ze_device_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Returns synchronized Host and device global timestamps."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads with"]
    #[doc = "       the same device handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == hostTimestamp`"]
    #[doc = "         + `nullptr == deviceTimestamp`"]
    pub fn zeDeviceGetGlobalTimestamps(
        hDevice: ze_device_handle_t,
        hostTimestamp: *mut u64,
        deviceTimestamp: *mut u64,
    ) -> ze_result_t;
}
impl _ze_context_flags_t {
    #[doc = "< reserved for future use"]
    pub const ZE_CONTEXT_FLAG_TBD: _ze_context_flags_t = _ze_context_flags_t(1);
}
impl _ze_context_flags_t {
    pub const ZE_CONTEXT_FLAG_FORCE_UINT32: _ze_context_flags_t = _ze_context_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_context_flags_t> for _ze_context_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_context_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_context_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_context_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_context_flags_t> for _ze_context_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_context_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_context_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_context_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported context creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_context_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported context creation flags"]
pub use self::_ze_context_flags_t as ze_context_flags_t;
#[doc = ""]
#[doc = " @brief Context descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_context_flags_t;"]
    #[doc = "< default behavior may use implicit driver-based heuristics."]
    pub flags: ze_context_flags_t,
}
#[test]
fn bindgen_test_layout__ze_context_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_context_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_context_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_context_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_context_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_context_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_context_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_context_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a context for the driver."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the context for the driver which was"]
    #[doc = "       provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeContextCreate(
        hDriver: ze_driver_handle_t,
        desc: *const ze_context_desc_t,
        phContext: *mut ze_context_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a context for the driver."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the context for the driver which was"]
    #[doc = "       provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phDevices) && (0 < numDevices)`"]
    pub fn zeContextCreateEx(
        hDriver: ze_driver_handle_t,
        desc: *const ze_context_desc_t,
        numDevices: u32,
        phDevices: *mut ze_device_handle_t,
        phContext: *mut ze_context_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the context before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same context handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeContextDestroy(hContext: ze_context_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Returns current status of the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads with"]
    #[doc = "       the same context handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "         + Context is available for use."]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "         + Context is invalid; due to device lost or reset."]
    pub fn zeContextGetStatus(hContext: ze_context_handle_t) -> ze_result_t;
}
impl _ze_command_queue_flags_t {
    #[doc = "< command queue should be optimized for submission to a single device engine."]
    #[doc = "< driver **must** disable any implicit optimizations for distributing"]
    #[doc = "< work across multiple engines."]
    #[doc = "< this flag should be used when applications want full control over"]
    #[doc = "< multi-engine submission and scheduling."]
    pub const ZE_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY: _ze_command_queue_flags_t =
        _ze_command_queue_flags_t(1);
}
impl _ze_command_queue_flags_t {
    pub const ZE_COMMAND_QUEUE_FLAG_FORCE_UINT32: _ze_command_queue_flags_t =
        _ze_command_queue_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_command_queue_flags_t> for _ze_command_queue_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_command_queue_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_command_queue_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_command_queue_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_command_queue_flags_t> for _ze_command_queue_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_command_queue_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_command_queue_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_command_queue_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported command queue flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_command_queue_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported command queue flags"]
pub use self::_ze_command_queue_flags_t as ze_command_queue_flags_t;
impl _ze_command_queue_mode_t {
    #[doc = "< implicit default behavior; uses driver-based heuristics"]
    pub const ZE_COMMAND_QUEUE_MODE_DEFAULT: _ze_command_queue_mode_t = _ze_command_queue_mode_t(0);
}
impl _ze_command_queue_mode_t {
    #[doc = "< Device execution always completes immediately on execute;"]
    #[doc = "< Host thread is blocked using wait on implicit synchronization object"]
    pub const ZE_COMMAND_QUEUE_MODE_SYNCHRONOUS: _ze_command_queue_mode_t =
        _ze_command_queue_mode_t(1);
}
impl _ze_command_queue_mode_t {
    #[doc = "< Device execution is scheduled and will complete in future;"]
    #[doc = "< explicit synchronization object must be used to determine completeness"]
    pub const ZE_COMMAND_QUEUE_MODE_ASYNCHRONOUS: _ze_command_queue_mode_t =
        _ze_command_queue_mode_t(2);
}
impl _ze_command_queue_mode_t {
    pub const ZE_COMMAND_QUEUE_MODE_FORCE_UINT32: _ze_command_queue_mode_t =
        _ze_command_queue_mode_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported command queue modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_command_queue_mode_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported command queue modes"]
pub use self::_ze_command_queue_mode_t as ze_command_queue_mode_t;
impl _ze_command_queue_priority_t {
    #[doc = "< [default] normal priority"]
    pub const ZE_COMMAND_QUEUE_PRIORITY_NORMAL: _ze_command_queue_priority_t =
        _ze_command_queue_priority_t(0);
}
impl _ze_command_queue_priority_t {
    #[doc = "< lower priority than normal"]
    pub const ZE_COMMAND_QUEUE_PRIORITY_PRIORITY_LOW: _ze_command_queue_priority_t =
        _ze_command_queue_priority_t(1);
}
impl _ze_command_queue_priority_t {
    #[doc = "< higher priority than normal"]
    pub const ZE_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH: _ze_command_queue_priority_t =
        _ze_command_queue_priority_t(2);
}
impl _ze_command_queue_priority_t {
    pub const ZE_COMMAND_QUEUE_PRIORITY_FORCE_UINT32: _ze_command_queue_priority_t =
        _ze_command_queue_priority_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported command queue priorities"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_command_queue_priority_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported command queue priorities"]
pub use self::_ze_command_queue_priority_t as ze_command_queue_priority_t;
#[doc = ""]
#[doc = " @brief Command Queue descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] command queue group ordinal"]
    pub ordinal: u32,
    #[doc = "< [in] command queue index within the group;"]
    #[doc = "< must be zero if ::ZE_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY is not set"]
    pub index: u32,
    #[doc = "< [in] usage flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_command_queue_flags_t;"]
    #[doc = "< default behavior may use implicit driver-based heuristics to balance"]
    #[doc = "< latency and throughput."]
    pub flags: ze_command_queue_flags_t,
    #[doc = "< [in] operation mode"]
    pub mode: ze_command_queue_mode_t,
    #[doc = "< [in] priority"]
    pub priority: ze_command_queue_priority_t,
}
#[test]
fn bindgen_test_layout__ze_command_queue_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_queue_desc_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_command_queue_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_queue_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_command_queue_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).ordinal as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(ordinal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).index as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).mode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).priority as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(priority)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a command queue on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - A command queue represents a logical input stream to the device, tied"]
    #[doc = "       to a physical input stream."]
    #[doc = "     - The application must only use the command queue for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clCreateCommandQueue**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < desc->flags`"]
    #[doc = "         + `::ZE_COMMAND_QUEUE_MODE_ASYNCHRONOUS < desc->mode`"]
    #[doc = "         + `::ZE_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH < desc->priority`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeCommandQueueCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *const ze_command_queue_desc_t,
        phCommandQueue: *mut ze_command_queue_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must destroy all fence handles created from the"]
    #[doc = "       command queue before destroying the command queue itself"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the command queue before it is deleted"]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this command queue"]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command queue handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clReleaseCommandQueue**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeCommandQueueDestroy(hCommandQueue: ze_command_queue_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Executes a command list in a command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The command lists are submitted to the device in the order they are"]
    #[doc = "       received, whether from multiple calls (on the same or different"]
    #[doc = "       threads) or a single call with multiple command lists."]
    #[doc = "     - The application must ensure the command lists are accessible by the"]
    #[doc = "       device on which the command queue was created."]
    #[doc = "     - The application must ensure the command lists are not currently"]
    #[doc = "       referencing the command list since the implementation is allowed to"]
    #[doc = "       modify the contents of the command list for submission."]
    #[doc = "     - The application must only execute command lists created with an"]
    #[doc = "       identical command queue group ordinal to the command queue."]
    #[doc = "     - The application must use a fence created using the same command queue."]
    #[doc = "     - The application must ensure the command queue, command list and fence"]
    #[doc = "       were created on the same context."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - vkQueueSubmit"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phCommandLists`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `0 == numCommandLists`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandQueueExecuteCommandLists(
        hCommandQueue: ze_command_queue_handle_t,
        numCommandLists: u32,
        phCommandLists: *mut ze_command_list_handle_t,
        hFence: ze_fence_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Synchronizes a command queue by waiting on the host."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + timeout expired"]
    pub fn zeCommandQueueSynchronize(
        hCommandQueue: ze_command_queue_handle_t,
        timeout: u64,
    ) -> ze_result_t;
}
impl _ze_command_list_flags_t {
    #[doc = "< driver may reorder commands (e.g., kernels, copies) between barriers"]
    #[doc = "< and synchronization primitives."]
    #[doc = "< using this flag may increase Host overhead of ::zeCommandListClose."]
    #[doc = "< therefore, this flag should **not** be set for low-latency usage-models."]
    pub const ZE_COMMAND_LIST_FLAG_RELAXED_ORDERING: _ze_command_list_flags_t =
        _ze_command_list_flags_t(1);
}
impl _ze_command_list_flags_t {
    #[doc = "< driver may perform additional optimizations that increase execution"]
    #[doc = "< throughput."]
    #[doc = "< using this flag may increase Host overhead of ::zeCommandListClose and ::zeCommandQueueExecuteCommandLists."]
    #[doc = "< therefore, this flag should **not** be set for low-latency usage-models."]
    pub const ZE_COMMAND_LIST_FLAG_MAXIMIZE_THROUGHPUT: _ze_command_list_flags_t =
        _ze_command_list_flags_t(2);
}
impl _ze_command_list_flags_t {
    #[doc = "< command list should be optimized for submission to a single command"]
    #[doc = "< queue and device engine."]
    #[doc = "< driver **must** disable any implicit optimizations for distributing"]
    #[doc = "< work across multiple engines."]
    #[doc = "< this flag should be used when applications want full control over"]
    #[doc = "< multi-engine submission and scheduling."]
    pub const ZE_COMMAND_LIST_FLAG_EXPLICIT_ONLY: _ze_command_list_flags_t =
        _ze_command_list_flags_t(4);
}
impl _ze_command_list_flags_t {
    pub const ZE_COMMAND_LIST_FLAG_FORCE_UINT32: _ze_command_list_flags_t =
        _ze_command_list_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_command_list_flags_t> for _ze_command_list_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_command_list_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_command_list_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_command_list_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_command_list_flags_t> for _ze_command_list_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_command_list_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_command_list_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_command_list_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported command list creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_command_list_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported command list creation flags"]
pub use self::_ze_command_list_flags_t as ze_command_list_flags_t;
#[doc = ""]
#[doc = " @brief Command List descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] command queue group ordinal to which this command list will be"]
    #[doc = "< submitted"]
    pub commandQueueGroupOrdinal: u32,
    #[doc = "< [in] usage flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_command_list_flags_t;"]
    #[doc = "< default behavior may use implicit driver-based heuristics to balance"]
    #[doc = "< latency and throughput."]
    pub flags: ze_command_list_flags_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_command_list_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_command_list_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_list_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_list_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_desc_t>())).commandQueueGroupOrdinal as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_desc_t),
            "::",
            stringify!(commandQueueGroupOrdinal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_list_desc_t>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a command list on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - A command list represents a sequence of commands for execution on a"]
    #[doc = "       command queue."]
    #[doc = "     - The command list is created in the 'open' state."]
    #[doc = "     - The application must only use the command list for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x7 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeCommandListCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *const ze_command_list_desc_t,
        phCommandList: *mut ze_command_list_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates an immediate command list on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - An immediate command list is used for low-latency submission of"]
    #[doc = "       commands."]
    #[doc = "     - An immediate command list creates an implicit command queue."]
    #[doc = "     - The command list is created in the 'open' state and never needs to be"]
    #[doc = "       closed."]
    #[doc = "     - The application must only use the command list for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == altdesc`"]
    #[doc = "         + `nullptr == phCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < altdesc->flags`"]
    #[doc = "         + `::ZE_COMMAND_QUEUE_MODE_ASYNCHRONOUS < altdesc->mode`"]
    #[doc = "         + `::ZE_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH < altdesc->priority`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeCommandListCreateImmediate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        altdesc: *const ze_command_queue_desc_t,
        phCommandList: *mut ze_command_list_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the command list before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this command list."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeCommandListDestroy(hCommandList: ze_command_list_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Closes a command list; ready to be executed by a command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    pub fn zeCommandListClose(hCommandList: ze_command_list_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Reset a command list to initial (empty) state; ready for appending"]
    #[doc = "        commands."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the command list before it is reset"]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    pub fn zeCommandListReset(hCommandList: ze_command_list_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a memory write of the device's global timestamp value into a"]
    #[doc = "        command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The timestamp frequency can be queried from"]
    #[doc = "       ::ze_device_properties_t.timerResolution."]
    #[doc = "     - The number of valid bits in the timestamp value can be queried from"]
    #[doc = "       ::ze_device_properties_t.timestampValidBits."]
    #[doc = "     - The application must ensure the memory pointed to by dstptr is"]
    #[doc = "       accessible by the device on which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendWriteGlobalTimestamp(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut u64,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends an execution and global memory barrier into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - If numWaitEvents is zero, then all previous commands are completed"]
    #[doc = "       prior to the execution of the barrier."]
    #[doc = "     - If numWaitEvents is non-zero, then then all phWaitEvents must be"]
    #[doc = "       signaled prior to the execution of the barrier."]
    #[doc = "     - This command blocks all following commands from beginning until the"]
    #[doc = "       execution of the barrier completes."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkCmdPipelineBarrier**"]
    #[doc = "     - clEnqueueBarrierWithWaitList"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendBarrier(
        hCommandList: ze_command_list_handle_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a global memory ranges barrier into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - If numWaitEvents is zero, then all previous commands are completed"]
    #[doc = "       prior to the execution of the barrier."]
    #[doc = "     - If numWaitEvents is non-zero, then then all phWaitEvents must be"]
    #[doc = "       signaled prior to the execution of the barrier."]
    #[doc = "     - This command blocks all following commands from beginning until the"]
    #[doc = "       execution of the barrier completes."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pRangeSizes`"]
    #[doc = "         + `nullptr == pRanges`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendMemoryRangesBarrier(
        hCommandList: ze_command_list_handle_t,
        numRanges: u32,
        pRangeSizes: *const usize,
        pRanges: *mut *const ::std::os::raw::c_void,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Ensures in-bound writes to the device are globally observable."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This is a special-case system level barrier that can be used to ensure"]
    #[doc = "       global observability of writes;"]
    #[doc = "       typically needed after a producer (e.g., NIC) performs direct writes"]
    #[doc = "       to the device's memory (e.g., Direct RDMA writes)."]
    #[doc = "       This is typically required when the memory corresponding to the writes"]
    #[doc = "       is subsequently accessed from a remote device."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    pub fn zeContextSystemBarrier(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies host, device, or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory pointed to by dstptr and srcptr"]
    #[doc = "       is accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by dstptr and"]
    #[doc = "       srcptr as they are free to be modified by either the Host or device up"]
    #[doc = "       until execution."]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clEnqueueCopyBuffer**"]
    #[doc = "     - **clEnqueueReadBuffer**"]
    #[doc = "     - **clEnqueueWriteBuffer**"]
    #[doc = "     - **clEnqueueSVMMemcpy**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "         + `nullptr == srcptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendMemoryCopy(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        srcptr: *const ::std::os::raw::c_void,
        size: usize,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Initializes host, device, or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory pointed to by dstptr is"]
    #[doc = "       accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by dstptr as"]
    #[doc = "       it is free to be modified by either the Host or device up until"]
    #[doc = "       execution."]
    #[doc = "     - The value to initialize memory to is described by the pattern and the"]
    #[doc = "       pattern size."]
    #[doc = "     - The pattern size must be a power-of-two and less than"]
    #[doc = "       ::ze_command_queue_group_properties_t.maxMemoryFillPatternSize."]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must enusre the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clEnqueueFillBuffer**"]
    #[doc = "     - **clEnqueueSVMMemFill**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "         + `nullptr == pattern`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendMemoryFill(
        hCommandList: ze_command_list_handle_t,
        ptr: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_void,
        pattern_size: usize,
        size: usize,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Copy region descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_copy_region_t {
    #[doc = "< [in] The origin x offset for region in bytes"]
    pub originX: u32,
    #[doc = "< [in] The origin y offset for region in rows"]
    pub originY: u32,
    #[doc = "< [in] The origin z offset for region in slices"]
    pub originZ: u32,
    #[doc = "< [in] The region width relative to origin in bytes"]
    pub width: u32,
    #[doc = "< [in] The region height relative to origin in rows"]
    pub height: u32,
    #[doc = "< [in] The region depth relative to origin in slices. Set this to 0 for"]
    #[doc = "< 2D copy."]
    pub depth: u32,
}
#[test]
fn bindgen_test_layout__ze_copy_region_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_copy_region_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_copy_region_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_copy_region_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_copy_region_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).originX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(originX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).originY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(originY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).originZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(originZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(depth)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies a region from a 2D or 3D array of host, device, or shared"]
    #[doc = "        memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory pointed to by dstptr and srcptr"]
    #[doc = "       is accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by dstptr and"]
    #[doc = "       srcptr as they are free to be modified by either the Host or device up"]
    #[doc = "       until execution."]
    #[doc = "     - The region width, height, and depth for both src and dst must be same."]
    #[doc = "       The origins can be different."]
    #[doc = "     - The src and dst regions cannot be overlapping."]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "         + `nullptr == dstRegion`"]
    #[doc = "         + `nullptr == srcptr`"]
    #[doc = "         + `nullptr == srcRegion`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OVERLAPPING_REGIONS"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendMemoryCopyRegion(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        dstRegion: *const ze_copy_region_t,
        dstPitch: u32,
        dstSlicePitch: u32,
        srcptr: *const ::std::os::raw::c_void,
        srcRegion: *const ze_copy_region_t,
        srcPitch: u32,
        srcSlicePitch: u32,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies host, device, or shared memory from another context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The current active and source context must be from the same driver."]
    #[doc = "     - The application must ensure the memory pointed to by dstptr and srcptr"]
    #[doc = "       is accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by dstptr and"]
    #[doc = "       srcptr as they are free to be modified by either the Host or device up"]
    #[doc = "       until execution."]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hContextSrc`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "         + `nullptr == srcptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendMemoryCopyFromContext(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        hContextSrc: ze_context_handle_t,
        srcptr: *const ::std::os::raw::c_void,
        size: usize,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies an image."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the image and events are accessible by the"]
    #[doc = "       device on which the command list was created."]
    #[doc = "     - The application must ensure the image format descriptors for both"]
    #[doc = "       source and destination images are the same."]
    #[doc = "     - The application must ensure the command list, images and events were"]
    #[doc = "       created on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clEnqueueCopyImage**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDstImage`"]
    #[doc = "         + `nullptr == hSrcImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendImageCopy(
        hCommandList: ze_command_list_handle_t,
        hDstImage: ze_image_handle_t,
        hSrcImage: ze_image_handle_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Region descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_region_t {
    #[doc = "< [in] The origin x offset for region in pixels"]
    pub originX: u32,
    #[doc = "< [in] The origin y offset for region in pixels"]
    pub originY: u32,
    #[doc = "< [in] The origin z offset for region in pixels"]
    pub originZ: u32,
    #[doc = "< [in] The region width relative to origin in pixels"]
    pub width: u32,
    #[doc = "< [in] The region height relative to origin in pixels"]
    pub height: u32,
    #[doc = "< [in] The region depth relative to origin. For 1D or 2D images, set"]
    #[doc = "< this to 1."]
    pub depth: u32,
}
#[test]
fn bindgen_test_layout__ze_image_region_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_region_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_image_region_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_region_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_image_region_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).originX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(originX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).originY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(originY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).originZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(originZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(depth)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies a region of an image to another image."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the image and events are accessible by the"]
    #[doc = "       device on which the command list was created."]
    #[doc = "     - The region width and height for both src and dst must be same. The"]
    #[doc = "       origins can be different."]
    #[doc = "     - The src and dst regions cannot be overlapping."]
    #[doc = "     - The application must ensure the image format descriptors for both"]
    #[doc = "       source and destination images are the same."]
    #[doc = "     - The application must ensure the command list, images and events were"]
    #[doc = "       created, and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDstImage`"]
    #[doc = "         + `nullptr == hSrcImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_OVERLAPPING_REGIONS"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendImageCopyRegion(
        hCommandList: ze_command_list_handle_t,
        hDstImage: ze_image_handle_t,
        hSrcImage: ze_image_handle_t,
        pDstRegion: *const ze_image_region_t,
        pSrcRegion: *const ze_image_region_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies from an image to device or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory pointed to by dstptr is"]
    #[doc = "       accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by dstptr as"]
    #[doc = "       it is free to be modified by either the Host or device up until"]
    #[doc = "       execution."]
    #[doc = "     - The application must ensure the image and events are accessible by the"]
    #[doc = "       device on which the command list was created."]
    #[doc = "     - The application must ensure the image format descriptor for the source"]
    #[doc = "       image is not a media format."]
    #[doc = "     - The application must ensure the command list, image and events were"]
    #[doc = "       created, and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clEnqueueReadImage"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hSrcImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendImageCopyToMemory(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        hSrcImage: ze_image_handle_t,
        pSrcRegion: *const ze_image_region_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies to an image from device or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory pointed to by srcptr is"]
    #[doc = "       accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by srcptr as"]
    #[doc = "       it is free to be modified by either the Host or device up until"]
    #[doc = "       execution."]
    #[doc = "     - The application must ensure the image and events are accessible by the"]
    #[doc = "       device on which the command list was created."]
    #[doc = "     - The application must ensure the image format descriptor for the"]
    #[doc = "       destination image is not a media format."]
    #[doc = "     - The application must ensure the command list, image and events were"]
    #[doc = "       created, and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clEnqueueWriteImage"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDstImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == srcptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendImageCopyFromMemory(
        hCommandList: ze_command_list_handle_t,
        hDstImage: ze_image_handle_t,
        srcptr: *const ::std::os::raw::c_void,
        pDstRegion: *const ze_image_region_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Asynchronously prefetches shared memory to the device associated with"]
    #[doc = "        the specified command list"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This is a hint to improve performance only and is not required for"]
    #[doc = "       correctness."]
    #[doc = "     - Only prefetching to the device associated with the specified command"]
    #[doc = "       list is supported."]
    #[doc = "       Prefetching to the host or to a peer device is not supported."]
    #[doc = "     - Prefetching may not be supported for all allocation types for all devices."]
    #[doc = "       If memory prefetching is not supported for the specified memory range"]
    #[doc = "       the prefetch hint may be ignored."]
    #[doc = "     - Prefetching may only be supported at a device-specific granularity,"]
    #[doc = "       such as at a page boundary."]
    #[doc = "       In this case, the memory range may be expanded such that the start and"]
    #[doc = "       end of the range satisfy granularity requirements."]
    #[doc = "     - The application must ensure the memory pointed to by ptr is accessible"]
    #[doc = "       by the device on which the command list was created."]
    #[doc = "     - The application must ensure the command list was created, and the"]
    #[doc = "       memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clEnqueueSVMMigrateMem"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeCommandListAppendMemoryPrefetch(
        hCommandList: ze_command_list_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
impl _ze_memory_advice_t {
    #[doc = "< hint that memory will be read from frequently and written to rarely"]
    pub const ZE_MEMORY_ADVICE_SET_READ_MOSTLY: _ze_memory_advice_t = _ze_memory_advice_t(0);
}
impl _ze_memory_advice_t {
    #[doc = "< removes the affect of ::ZE_MEMORY_ADVICE_SET_READ_MOSTLY"]
    pub const ZE_MEMORY_ADVICE_CLEAR_READ_MOSTLY: _ze_memory_advice_t = _ze_memory_advice_t(1);
}
impl _ze_memory_advice_t {
    #[doc = "< hint that the preferred memory location is the specified device"]
    pub const ZE_MEMORY_ADVICE_SET_PREFERRED_LOCATION: _ze_memory_advice_t = _ze_memory_advice_t(2);
}
impl _ze_memory_advice_t {
    #[doc = "< removes the affect of ::ZE_MEMORY_ADVICE_SET_PREFERRED_LOCATION"]
    pub const ZE_MEMORY_ADVICE_CLEAR_PREFERRED_LOCATION: _ze_memory_advice_t =
        _ze_memory_advice_t(3);
}
impl _ze_memory_advice_t {
    #[doc = "< hints that memory will mostly be accessed non-atomically"]
    pub const ZE_MEMORY_ADVICE_SET_NON_ATOMIC_MOSTLY: _ze_memory_advice_t = _ze_memory_advice_t(4);
}
impl _ze_memory_advice_t {
    #[doc = "< removes the affect of ::ZE_MEMORY_ADVICE_SET_NON_ATOMIC_MOSTLY"]
    pub const ZE_MEMORY_ADVICE_CLEAR_NON_ATOMIC_MOSTLY: _ze_memory_advice_t =
        _ze_memory_advice_t(5);
}
impl _ze_memory_advice_t {
    #[doc = "< hints that memory should be cached"]
    pub const ZE_MEMORY_ADVICE_BIAS_CACHED: _ze_memory_advice_t = _ze_memory_advice_t(6);
}
impl _ze_memory_advice_t {
    #[doc = "< hints that memory should be not be cached"]
    pub const ZE_MEMORY_ADVICE_BIAS_UNCACHED: _ze_memory_advice_t = _ze_memory_advice_t(7);
}
impl _ze_memory_advice_t {
    pub const ZE_MEMORY_ADVICE_FORCE_UINT32: _ze_memory_advice_t = _ze_memory_advice_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported memory advice hints"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_memory_advice_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported memory advice hints"]
pub use self::_ze_memory_advice_t as ze_memory_advice_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Provides advice about the use of a shared memory range"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Memory advice is a performance hint only and is not required for"]
    #[doc = "       functional correctness."]
    #[doc = "     - Memory advice can be used to override driver heuristics to explicitly"]
    #[doc = "       control shared memory behavior."]
    #[doc = "     - Not all memory advice hints may be supported for all allocation types"]
    #[doc = "       for all devices."]
    #[doc = "       If a memory advice hint is not supported by the device it will be ignored."]
    #[doc = "     - Memory advice may only be supported at a device-specific granularity,"]
    #[doc = "       such as at a page boundary."]
    #[doc = "       In this case, the memory range may be expanded such that the start and"]
    #[doc = "       end of the range satisfy granularity requirements."]
    #[doc = "     - The application must ensure the memory pointed to by ptr is accessible"]
    #[doc = "       by the device on which the command list was created."]
    #[doc = "     - The application must ensure the command list was created, and memory"]
    #[doc = "       was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle, and the memory was"]
    #[doc = "       allocated."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `::ZE_MEMORY_ADVICE_BIAS_UNCACHED < advice`"]
    pub fn zeCommandListAppendMemAdvise(
        hCommandList: ze_command_list_handle_t,
        hDevice: ze_device_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        advice: ze_memory_advice_t,
    ) -> ze_result_t;
}
impl _ze_event_pool_flags_t {
    #[doc = "< signals and waits are also visible to host"]
    pub const ZE_EVENT_POOL_FLAG_HOST_VISIBLE: _ze_event_pool_flags_t = _ze_event_pool_flags_t(1);
}
impl _ze_event_pool_flags_t {
    #[doc = "< signals and waits may be shared across processes"]
    pub const ZE_EVENT_POOL_FLAG_IPC: _ze_event_pool_flags_t = _ze_event_pool_flags_t(2);
}
impl _ze_event_pool_flags_t {
    #[doc = "< Indicates all events in pool will contain kernel timestamps; cannot be"]
    #[doc = "< combined with ::ZE_EVENT_POOL_FLAG_IPC"]
    pub const ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP: _ze_event_pool_flags_t =
        _ze_event_pool_flags_t(4);
}
impl _ze_event_pool_flags_t {
    pub const ZE_EVENT_POOL_FLAG_FORCE_UINT32: _ze_event_pool_flags_t =
        _ze_event_pool_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_event_pool_flags_t> for _ze_event_pool_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_event_pool_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_event_pool_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_event_pool_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_event_pool_flags_t> for _ze_event_pool_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_event_pool_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_event_pool_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_event_pool_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported event pool creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_event_pool_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported event pool creation flags"]
pub use self::_ze_event_pool_flags_t as ze_event_pool_flags_t;
#[doc = ""]
#[doc = " @brief Event pool descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_pool_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_event_pool_flags_t;"]
    #[doc = "< default behavior is signals and waits are visible to the entire device"]
    #[doc = "< and peer devices."]
    pub flags: ze_event_pool_flags_t,
    #[doc = "< [in] number of events within the pool; must be greater than 0"]
    pub count: u32,
}
#[test]
fn bindgen_test_layout__ze_event_pool_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_pool_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_event_pool_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_pool_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_pool_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_pool_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_pool_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_pool_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_pool_desc_t>())).count as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_desc_t),
            "::",
            stringify!(count)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a pool of events on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use events within the pool for the"]
    #[doc = "       device(s), or their sub-devices, which were provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x7 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `0 == desc->count`"]
    #[doc = "         + `(nullptr == phDevices) && (0 < numDevices)`"]
    pub fn zeEventPoolCreate(
        hContext: ze_context_handle_t,
        desc: *const ze_event_pool_desc_t,
        numDevices: u32,
        phDevices: *mut ze_device_handle_t,
        phEventPool: *mut ze_event_pool_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes an event pool object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must destroy all event handles created from the pool"]
    #[doc = "       before destroying the pool itself."]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the any event within the pool before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this event pool."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same event pool handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeEventPoolDestroy(hEventPool: ze_event_pool_handle_t) -> ze_result_t;
}
impl _ze_event_scope_flags_t {
    #[doc = "< cache hierarchies are flushed or invalidated sufficient for local"]
    #[doc = "< sub-device access"]
    pub const ZE_EVENT_SCOPE_FLAG_SUBDEVICE: _ze_event_scope_flags_t = _ze_event_scope_flags_t(1);
}
impl _ze_event_scope_flags_t {
    #[doc = "< cache hierarchies are flushed or invalidated sufficient for global"]
    #[doc = "< device access and peer device access"]
    pub const ZE_EVENT_SCOPE_FLAG_DEVICE: _ze_event_scope_flags_t = _ze_event_scope_flags_t(2);
}
impl _ze_event_scope_flags_t {
    #[doc = "< cache hierarchies are flushed or invalidated sufficient for device and"]
    #[doc = "< host access"]
    pub const ZE_EVENT_SCOPE_FLAG_HOST: _ze_event_scope_flags_t = _ze_event_scope_flags_t(4);
}
impl _ze_event_scope_flags_t {
    pub const ZE_EVENT_SCOPE_FLAG_FORCE_UINT32: _ze_event_scope_flags_t =
        _ze_event_scope_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_event_scope_flags_t> for _ze_event_scope_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_event_scope_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_event_scope_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_event_scope_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_event_scope_flags_t> for _ze_event_scope_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_event_scope_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_event_scope_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_event_scope_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported event scope flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_event_scope_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported event scope flags"]
pub use self::_ze_event_scope_flags_t as ze_event_scope_flags_t;
#[doc = ""]
#[doc = " @brief Event descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] index of the event within the pool; must be less-than the count"]
    #[doc = "< specified during pool creation"]
    pub index: u32,
    #[doc = "< [in] defines the scope of relevant cache hierarchies to flush on a"]
    #[doc = "< signal action before the event is triggered."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_event_scope_flags_t;"]
    #[doc = "< default behavior is synchronization within the command list only, no"]
    #[doc = "< additional cache hierarchies are flushed."]
    pub signal: ze_event_scope_flags_t,
    #[doc = "< [in] defines the scope of relevant cache hierarchies to invalidate on"]
    #[doc = "< a wait action after the event is complete."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_event_scope_flags_t;"]
    #[doc = "< default behavior is synchronization within the command list only, no"]
    #[doc = "< additional cache hierarchies are invalidated."]
    pub wait: ze_event_scope_flags_t,
}
#[test]
fn bindgen_test_layout__ze_event_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_desc_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_event_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).signal as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).wait as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(wait)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates an event from the pool."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - An event is used to communicate fine-grain host-to-device,"]
    #[doc = "       device-to-host or device-to-device dependencies have completed."]
    #[doc = "     - The application must ensure the location in the pool is not being used"]
    #[doc = "       by another event."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same event pool handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clCreateUserEvent**"]
    #[doc = "     - vkCreateEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x7 < desc->signal`"]
    #[doc = "         + `0x7 < desc->wait`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    pub fn zeEventCreate(
        hEventPool: ze_event_pool_handle_t,
        desc: *const ze_event_desc_t,
        phEvent: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes an event object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the event before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this event."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same event handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clReleaseEvent**"]
    #[doc = "     - vkDestroyEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeEventDestroy(hEvent: ze_event_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Gets an IPC event pool handle for the specified event handle that can"]
    #[doc = "        be shared with another process."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Event pool must have been created with ::ZE_EVENT_POOL_FLAG_IPC."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phIpc`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeEventPoolGetIpcHandle(
        hEventPool: ze_event_pool_handle_t,
        phIpc: *mut ze_ipc_event_pool_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Opens an IPC event pool handle to retrieve an event pool handle from"]
    #[doc = "        another process."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Multiple calls to this function with the same IPC handle will return"]
    #[doc = "       unique event pool handles."]
    #[doc = "     - The event handle in this process should not be freed with"]
    #[doc = "       ::zeEventPoolDestroy, but rather with ::zeEventPoolCloseIpcHandle."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phEventPool`"]
    pub fn zeEventPoolOpenIpcHandle(
        hContext: ze_context_handle_t,
        hIpc: ze_ipc_event_pool_handle_t,
        phEventPool: *mut ze_event_pool_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Closes an IPC event handle in the current process."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Closes an IPC event handle by destroying events that were opened in"]
    #[doc = "       this process using ::zeEventPoolOpenIpcHandle."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same event pool handle."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    pub fn zeEventPoolCloseIpcHandle(hEventPool: ze_event_pool_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a signal of the event from the device into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The duration of an event created from an event pool that was created"]
    #[doc = "       using ::ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag is undefined."]
    #[doc = "       However, for consistency and orthogonality the event will report"]
    #[doc = "       correctly as signaled when used by other event API functionality."]
    #[doc = "     - The application must ensure the command list and events were created"]
    #[doc = "       on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clSetUserEventStatus**"]
    #[doc = "     - vkCmdSetEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendSignalEvent(
        hCommandList: ze_command_list_handle_t,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends wait on event(s) on the device into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created"]
    #[doc = "       on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phEvents`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendWaitOnEvents(
        hCommandList: ze_command_list_handle_t,
        numEvents: u32,
        phEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Signals a event from host."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The duration of an event created from an event pool that was created"]
    #[doc = "       using ::ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag is undefined."]
    #[doc = "       However, for consistency and orthogonality the event will report"]
    #[doc = "       correctly as signaled when used by other event API functionality."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clSetUserEventStatus"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeEventHostSignal(hEvent: ze_event_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief The current host thread waits on an event to be signaled."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clWaitForEvents"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + timeout expired"]
    pub fn zeEventHostSynchronize(hEvent: ze_event_handle_t, timeout: u64) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries an event object's status on the host."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clGetEventInfo**"]
    #[doc = "     - vkGetEventStatus"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + not signaled"]
    pub fn zeEventQueryStatus(hEvent: ze_event_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a reset of an event back to not signaled state into a command"]
    #[doc = "        list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created"]
    #[doc = "       on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - vkResetEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendEventReset(
        hCommandList: ze_command_list_handle_t,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief The current host thread resets an event back to not signaled state."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - vkResetEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeEventHostReset(hEvent: ze_event_handle_t) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Kernel timestamp clock data"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - The timestamp frequency can be queried from"]
#[doc = "       ::ze_device_properties_t.timerResolution."]
#[doc = "     - The number of valid bits in the timestamp value can be queried from"]
#[doc = "       ::ze_device_properties_t.kernelTimestampValidBits."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_timestamp_data_t {
    #[doc = "< [out] device clock at start of kernel execution"]
    pub kernelStart: u64,
    #[doc = "< [out] device clock at end of kernel execution"]
    pub kernelEnd: u64,
}
#[test]
fn bindgen_test_layout__ze_kernel_timestamp_data_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_timestamp_data_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_kernel_timestamp_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_timestamp_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_timestamp_data_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_timestamp_data_t>())).kernelStart as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_timestamp_data_t),
            "::",
            stringify!(kernelStart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_timestamp_data_t>())).kernelEnd as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_timestamp_data_t),
            "::",
            stringify!(kernelEnd)
        )
    );
}
#[doc = ""]
#[doc = " @brief Kernel timestamp result"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_timestamp_result_t {
    #[doc = "< [out] wall-clock data"]
    pub global: ze_kernel_timestamp_data_t,
    #[doc = "< [out] context-active data; only includes clocks while device context"]
    #[doc = "< was actively executing."]
    pub context: ze_kernel_timestamp_data_t,
}
#[test]
fn bindgen_test_layout__ze_kernel_timestamp_result_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_timestamp_result_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_kernel_timestamp_result_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_timestamp_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_timestamp_result_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_timestamp_result_t>())).global as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_timestamp_result_t),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_timestamp_result_t>())).context as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_timestamp_result_t),
            "::",
            stringify!(context)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries an event's timestamp value on the host."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the event was created from an event pool"]
    #[doc = "       that was created using ::ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag."]
    #[doc = "     - The destination memory will be unmodified if the event has not been"]
    #[doc = "       signaled."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + not signaled"]
    pub fn zeEventQueryKernelTimestamp(
        hEvent: ze_event_handle_t,
        dstptr: *mut ze_kernel_timestamp_result_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a query of an events' timestamp value(s) into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the events were created from an event pool"]
    #[doc = "       that was created using ::ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag."]
    #[doc = "     - The application must ensure the memory pointed to by both dstptr and"]
    #[doc = "       pOffsets is accessible by the device on which the command list was"]
    #[doc = "       created."]
    #[doc = "     - The value(s) written to the destination buffer are undefined if any"]
    #[doc = "       timestamp event has not been signaled."]
    #[doc = "     - If pOffsets is nullptr, then multiple results will be appended"]
    #[doc = "       sequentially into memory in the same order as phEvents."]
    #[doc = "     - The application must ensure the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phEvents`"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendQueryKernelTimestamps(
        hCommandList: ze_command_list_handle_t,
        numEvents: u32,
        phEvents: *mut ze_event_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        pOffsets: *const usize,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
impl _ze_fence_flags_t {
    #[doc = "< fence is created in the signaled state, otherwise not signaled."]
    pub const ZE_FENCE_FLAG_SIGNALED: _ze_fence_flags_t = _ze_fence_flags_t(1);
}
impl _ze_fence_flags_t {
    pub const ZE_FENCE_FLAG_FORCE_UINT32: _ze_fence_flags_t = _ze_fence_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_fence_flags_t> for _ze_fence_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_fence_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_fence_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_fence_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_fence_flags_t> for _ze_fence_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_fence_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_fence_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_fence_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported fence creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_fence_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported fence creation flags"]
pub use self::_ze_fence_flags_t as ze_fence_flags_t;
#[doc = ""]
#[doc = " @brief Fence descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_fence_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_fence_flags_t."]
    pub flags: ze_fence_flags_t,
}
#[test]
fn bindgen_test_layout__ze_fence_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_fence_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_fence_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_fence_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_fence_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_fence_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_fence_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_fence_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a fence for the command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - A fence is a heavyweight synchronization primitive used to communicate"]
    #[doc = "       to the host that command list execution has completed."]
    #[doc = "     - The application must only use the fence for the command queue which"]
    #[doc = "       was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkCreateFence**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeFenceCreate(
        hCommandQueue: ze_command_queue_handle_t,
        desc: *const ze_fence_desc_t,
        phFence: *mut ze_fence_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes a fence object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the fence before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this fence."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same fence handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkDestroyFence**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeFenceDestroy(hFence: ze_fence_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief The current host thread waits on a fence to be signaled."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkWaitForFences**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + timeout expired"]
    pub fn zeFenceHostSynchronize(hFence: ze_fence_handle_t, timeout: u64) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries a fence object's status."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkGetFenceStatus**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + not signaled"]
    pub fn zeFenceQueryStatus(hFence: ze_fence_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Reset a fence back to the not signaled state."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkResetFences**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    pub fn zeFenceReset(hFence: ze_fence_handle_t) -> ze_result_t;
}
impl _ze_image_flags_t {
    #[doc = "< kernels will write contents"]
    pub const ZE_IMAGE_FLAG_KERNEL_WRITE: _ze_image_flags_t = _ze_image_flags_t(1);
}
impl _ze_image_flags_t {
    #[doc = "< device should not cache contents"]
    pub const ZE_IMAGE_FLAG_BIAS_UNCACHED: _ze_image_flags_t = _ze_image_flags_t(2);
}
impl _ze_image_flags_t {
    pub const ZE_IMAGE_FLAG_FORCE_UINT32: _ze_image_flags_t = _ze_image_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_image_flags_t> for _ze_image_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_image_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_image_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_image_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_image_flags_t> for _ze_image_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_image_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_image_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_image_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported image creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported image creation flags"]
pub use self::_ze_image_flags_t as ze_image_flags_t;
impl _ze_image_type_t {
    #[doc = "< 1D"]
    pub const ZE_IMAGE_TYPE_1D: _ze_image_type_t = _ze_image_type_t(0);
}
impl _ze_image_type_t {
    #[doc = "< 1D array"]
    pub const ZE_IMAGE_TYPE_1DARRAY: _ze_image_type_t = _ze_image_type_t(1);
}
impl _ze_image_type_t {
    #[doc = "< 2D"]
    pub const ZE_IMAGE_TYPE_2D: _ze_image_type_t = _ze_image_type_t(2);
}
impl _ze_image_type_t {
    #[doc = "< 2D array"]
    pub const ZE_IMAGE_TYPE_2DARRAY: _ze_image_type_t = _ze_image_type_t(3);
}
impl _ze_image_type_t {
    #[doc = "< 3D"]
    pub const ZE_IMAGE_TYPE_3D: _ze_image_type_t = _ze_image_type_t(4);
}
impl _ze_image_type_t {
    #[doc = "< Buffer"]
    pub const ZE_IMAGE_TYPE_BUFFER: _ze_image_type_t = _ze_image_type_t(5);
}
impl _ze_image_type_t {
    pub const ZE_IMAGE_TYPE_FORCE_UINT32: _ze_image_type_t = _ze_image_type_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported image types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_type_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported image types"]
pub use self::_ze_image_type_t as ze_image_type_t;
impl _ze_image_format_layout_t {
    #[doc = "< 8-bit single component layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_8: _ze_image_format_layout_t = _ze_image_format_layout_t(0);
}
impl _ze_image_format_layout_t {
    #[doc = "< 16-bit single component layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_16: _ze_image_format_layout_t = _ze_image_format_layout_t(1);
}
impl _ze_image_format_layout_t {
    #[doc = "< 32-bit single component layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_32: _ze_image_format_layout_t = _ze_image_format_layout_t(2);
}
impl _ze_image_format_layout_t {
    #[doc = "< 2-component 8-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_8_8: _ze_image_format_layout_t = _ze_image_format_layout_t(3);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 8-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_8_8_8_8: _ze_image_format_layout_t =
        _ze_image_format_layout_t(4);
}
impl _ze_image_format_layout_t {
    #[doc = "< 2-component 16-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_16_16: _ze_image_format_layout_t =
        _ze_image_format_layout_t(5);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 16-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_16_16_16_16: _ze_image_format_layout_t =
        _ze_image_format_layout_t(6);
}
impl _ze_image_format_layout_t {
    #[doc = "< 2-component 32-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_32_32: _ze_image_format_layout_t =
        _ze_image_format_layout_t(7);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 32-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_32_32_32_32: _ze_image_format_layout_t =
        _ze_image_format_layout_t(8);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 10_10_10_2 layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_10_10_10_2: _ze_image_format_layout_t =
        _ze_image_format_layout_t(9);
}
impl _ze_image_format_layout_t {
    #[doc = "< 3-component 11_11_10 layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_11_11_10: _ze_image_format_layout_t =
        _ze_image_format_layout_t(10);
}
impl _ze_image_format_layout_t {
    #[doc = "< 3-component 5_6_5 layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_5_6_5: _ze_image_format_layout_t =
        _ze_image_format_layout_t(11);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 5_5_5_1 layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_5_5_5_1: _ze_image_format_layout_t =
        _ze_image_format_layout_t(12);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 4_4_4_4 layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_4_4_4_4: _ze_image_format_layout_t =
        _ze_image_format_layout_t(13);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y8. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y8: _ze_image_format_layout_t = _ze_image_format_layout_t(14);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: NV12. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_NV12: _ze_image_format_layout_t =
        _ze_image_format_layout_t(15);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: YUYV. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_YUYV: _ze_image_format_layout_t =
        _ze_image_format_layout_t(16);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: VYUY. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_VYUY: _ze_image_format_layout_t =
        _ze_image_format_layout_t(17);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: YVYU. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_YVYU: _ze_image_format_layout_t =
        _ze_image_format_layout_t(18);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: UYVY. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_UYVY: _ze_image_format_layout_t =
        _ze_image_format_layout_t(19);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: AYUV. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_AYUV: _ze_image_format_layout_t =
        _ze_image_format_layout_t(20);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: P010. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_P010: _ze_image_format_layout_t =
        _ze_image_format_layout_t(21);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y410. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y410: _ze_image_format_layout_t =
        _ze_image_format_layout_t(22);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: P012. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_P012: _ze_image_format_layout_t =
        _ze_image_format_layout_t(23);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y16. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y16: _ze_image_format_layout_t = _ze_image_format_layout_t(24);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: P016. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_P016: _ze_image_format_layout_t =
        _ze_image_format_layout_t(25);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y216. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y216: _ze_image_format_layout_t =
        _ze_image_format_layout_t(26);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: P216. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_P216: _ze_image_format_layout_t =
        _ze_image_format_layout_t(27);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: P8. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_P8: _ze_image_format_layout_t = _ze_image_format_layout_t(28);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: YUY2. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_YUY2: _ze_image_format_layout_t =
        _ze_image_format_layout_t(29);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: A8P8. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_A8P8: _ze_image_format_layout_t =
        _ze_image_format_layout_t(30);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: IA44. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_IA44: _ze_image_format_layout_t =
        _ze_image_format_layout_t(31);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: AI44. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_AI44: _ze_image_format_layout_t =
        _ze_image_format_layout_t(32);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y416. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y416: _ze_image_format_layout_t =
        _ze_image_format_layout_t(33);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y210. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y210: _ze_image_format_layout_t =
        _ze_image_format_layout_t(34);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: I420. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_I420: _ze_image_format_layout_t =
        _ze_image_format_layout_t(35);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: YV12. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_YV12: _ze_image_format_layout_t =
        _ze_image_format_layout_t(36);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: 400P. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_400P: _ze_image_format_layout_t =
        _ze_image_format_layout_t(37);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: 422H. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_422H: _ze_image_format_layout_t =
        _ze_image_format_layout_t(38);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: 422V. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_422V: _ze_image_format_layout_t =
        _ze_image_format_layout_t(39);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: 444P. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_444P: _ze_image_format_layout_t =
        _ze_image_format_layout_t(40);
}
impl _ze_image_format_layout_t {
    pub const ZE_IMAGE_FORMAT_LAYOUT_FORCE_UINT32: _ze_image_format_layout_t =
        _ze_image_format_layout_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported image format layouts"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_format_layout_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported image format layouts"]
pub use self::_ze_image_format_layout_t as ze_image_format_layout_t;
impl _ze_image_format_type_t {
    #[doc = "< Unsigned integer"]
    pub const ZE_IMAGE_FORMAT_TYPE_UINT: _ze_image_format_type_t = _ze_image_format_type_t(0);
}
impl _ze_image_format_type_t {
    #[doc = "< Signed integer"]
    pub const ZE_IMAGE_FORMAT_TYPE_SINT: _ze_image_format_type_t = _ze_image_format_type_t(1);
}
impl _ze_image_format_type_t {
    #[doc = "< Unsigned normalized integer"]
    pub const ZE_IMAGE_FORMAT_TYPE_UNORM: _ze_image_format_type_t = _ze_image_format_type_t(2);
}
impl _ze_image_format_type_t {
    #[doc = "< Signed normalized integer"]
    pub const ZE_IMAGE_FORMAT_TYPE_SNORM: _ze_image_format_type_t = _ze_image_format_type_t(3);
}
impl _ze_image_format_type_t {
    #[doc = "< Float"]
    pub const ZE_IMAGE_FORMAT_TYPE_FLOAT: _ze_image_format_type_t = _ze_image_format_type_t(4);
}
impl _ze_image_format_type_t {
    pub const ZE_IMAGE_FORMAT_TYPE_FORCE_UINT32: _ze_image_format_type_t =
        _ze_image_format_type_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported image format types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_format_type_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported image format types"]
pub use self::_ze_image_format_type_t as ze_image_format_type_t;
impl _ze_image_format_swizzle_t {
    #[doc = "< Red component"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_R: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(0);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< Green component"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_G: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(1);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< Blue component"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_B: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(2);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< Alpha component"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_A: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(3);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< Zero"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_0: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(4);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< One"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_1: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(5);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< Don't care"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_X: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(6);
}
impl _ze_image_format_swizzle_t {
    pub const ZE_IMAGE_FORMAT_SWIZZLE_FORCE_UINT32: _ze_image_format_swizzle_t =
        _ze_image_format_swizzle_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported image format component swizzle into channel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_format_swizzle_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported image format component swizzle into channel"]
pub use self::_ze_image_format_swizzle_t as ze_image_format_swizzle_t;
#[doc = ""]
#[doc = " @brief Image format"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_format_t {
    #[doc = "< [in] image format component layout"]
    pub layout: ze_image_format_layout_t,
    #[doc = "< [in] image format type. Media formats can't be used for"]
    #[doc = "< ::ZE_IMAGE_TYPE_BUFFER."]
    pub type_: ze_image_format_type_t,
    #[doc = "< [in] image component swizzle into channel x"]
    pub x: ze_image_format_swizzle_t,
    #[doc = "< [in] image component swizzle into channel y"]
    pub y: ze_image_format_swizzle_t,
    #[doc = "< [in] image component swizzle into channel z"]
    pub z: ze_image_format_swizzle_t,
    #[doc = "< [in] image component swizzle into channel w"]
    pub w: ze_image_format_swizzle_t,
}
#[test]
fn bindgen_test_layout__ze_image_format_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_format_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_image_format_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_format_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_image_format_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).layout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).w as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(w)
        )
    );
}
#[doc = ""]
#[doc = " @brief Image descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_image_flags_t;"]
    #[doc = "< default is read-only, cached access."]
    pub flags: ze_image_flags_t,
    #[doc = "< [in] image type"]
    pub type_: ze_image_type_t,
    #[doc = "< [in] image format"]
    pub format: ze_image_format_t,
    #[doc = "< [in] width dimension."]
    #[doc = "< ::ZE_IMAGE_TYPE_BUFFER: size in bytes; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageBufferSize for limits."]
    #[doc = "< ::ZE_IMAGE_TYPE_1D, ::ZE_IMAGE_TYPE_1DARRAY: width in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims1D for limits."]
    #[doc = "< ::ZE_IMAGE_TYPE_2D, ::ZE_IMAGE_TYPE_2DARRAY: width in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims2D for limits."]
    #[doc = "< ::ZE_IMAGE_TYPE_3D: width in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims3D for limits."]
    pub width: u64,
    #[doc = "< [in] height dimension."]
    #[doc = "< ::ZE_IMAGE_TYPE_2D, ::ZE_IMAGE_TYPE_2DARRAY: height in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims2D for limits."]
    #[doc = "< ::ZE_IMAGE_TYPE_3D: height in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims3D for limits."]
    #[doc = "< other: ignored."]
    pub height: u32,
    #[doc = "< [in] depth dimension."]
    #[doc = "< ::ZE_IMAGE_TYPE_3D: depth in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims3D for limits."]
    #[doc = "< other: ignored."]
    pub depth: u32,
    #[doc = "< [in] array levels."]
    #[doc = "< ::ZE_IMAGE_TYPE_1DARRAY, ::ZE_IMAGE_TYPE_2DARRAY: see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageArraySlices for limits."]
    #[doc = "< other: ignored."]
    pub arraylevels: u32,
    #[doc = "< [in] mipmap levels (must be 0)"]
    pub miplevels: u32,
}
#[test]
fn bindgen_test_layout__ze_image_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_desc_t>(),
        72usize,
        concat!("Size of: ", stringify!(_ze_image_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_image_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).type_ as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).width as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).height as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).depth as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).arraylevels as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(arraylevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).miplevels as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(miplevels)
        )
    );
}
impl _ze_image_sampler_filter_flags_t {
    #[doc = "< device supports point filtering"]
    pub const ZE_IMAGE_SAMPLER_FILTER_FLAG_POINT: _ze_image_sampler_filter_flags_t =
        _ze_image_sampler_filter_flags_t(1);
}
impl _ze_image_sampler_filter_flags_t {
    #[doc = "< device supports linear filtering"]
    pub const ZE_IMAGE_SAMPLER_FILTER_FLAG_LINEAR: _ze_image_sampler_filter_flags_t =
        _ze_image_sampler_filter_flags_t(2);
}
impl _ze_image_sampler_filter_flags_t {
    pub const ZE_IMAGE_SAMPLER_FILTER_FLAG_FORCE_UINT32: _ze_image_sampler_filter_flags_t =
        _ze_image_sampler_filter_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_image_sampler_filter_flags_t> for _ze_image_sampler_filter_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_image_sampler_filter_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_image_sampler_filter_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_image_sampler_filter_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_image_sampler_filter_flags_t> for _ze_image_sampler_filter_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_image_sampler_filter_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_image_sampler_filter_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_image_sampler_filter_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported sampler filtering flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_sampler_filter_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported sampler filtering flags"]
pub use self::_ze_image_sampler_filter_flags_t as ze_image_sampler_filter_flags_t;
#[doc = ""]
#[doc = " @brief Image properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] supported sampler filtering."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_image_sampler_filter_flags_t."]
    pub samplerFilterFlags: ze_image_sampler_filter_flags_t,
}
#[test]
fn bindgen_test_layout__ze_image_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_image_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_image_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_properties_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_properties_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_properties_t>())).samplerFilterFlags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_properties_t),
            "::",
            stringify!(samplerFilterFlags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves supported properties of an image."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == pImageProperties`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < desc->flags`"]
    #[doc = "         + `::ZE_IMAGE_TYPE_BUFFER < desc->type`"]
    pub fn zeImageGetProperties(
        hDevice: ze_device_handle_t,
        desc: *const ze_image_desc_t,
        pImageProperties: *mut ze_image_properties_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates an image on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the image for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clCreateImage"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < desc->flags`"]
    #[doc = "         + `::ZE_IMAGE_TYPE_BUFFER < desc->type`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeImageCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *const ze_image_desc_t,
        phImage: *mut ze_image_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes an image object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the image before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this image."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same image handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeImageDestroy(hImage: ze_image_handle_t) -> ze_result_t;
}
impl _ze_device_mem_alloc_flags_t {
    #[doc = "< device should cache allocation"]
    pub const ZE_DEVICE_MEM_ALLOC_FLAG_BIAS_CACHED: _ze_device_mem_alloc_flags_t =
        _ze_device_mem_alloc_flags_t(1);
}
impl _ze_device_mem_alloc_flags_t {
    #[doc = "< device should not cache allocation (UC)"]
    pub const ZE_DEVICE_MEM_ALLOC_FLAG_BIAS_UNCACHED: _ze_device_mem_alloc_flags_t =
        _ze_device_mem_alloc_flags_t(2);
}
impl _ze_device_mem_alloc_flags_t {
    pub const ZE_DEVICE_MEM_ALLOC_FLAG_FORCE_UINT32: _ze_device_mem_alloc_flags_t =
        _ze_device_mem_alloc_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_mem_alloc_flags_t> for _ze_device_mem_alloc_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_mem_alloc_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_mem_alloc_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_mem_alloc_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_mem_alloc_flags_t> for _ze_device_mem_alloc_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_mem_alloc_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_mem_alloc_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_mem_alloc_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported memory allocation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_mem_alloc_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported memory allocation flags"]
pub use self::_ze_device_mem_alloc_flags_t as ze_device_mem_alloc_flags_t;
#[doc = ""]
#[doc = " @brief Device memory allocation descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_mem_alloc_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] flags specifying additional allocation controls."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_device_mem_alloc_flags_t;"]
    #[doc = "< default behavior may use implicit driver-based heuristics."]
    pub flags: ze_device_mem_alloc_flags_t,
    #[doc = "< [in] ordinal of the device's local memory to allocate from."]
    #[doc = "< must be less than the count returned from ::zeDeviceGetMemoryProperties."]
    pub ordinal: u32,
}
#[test]
fn bindgen_test_layout__ze_device_mem_alloc_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_mem_alloc_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_device_mem_alloc_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_mem_alloc_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_mem_alloc_desc_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_mem_alloc_desc_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_mem_alloc_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_mem_alloc_desc_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_mem_alloc_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_mem_alloc_desc_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_mem_alloc_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_mem_alloc_desc_t>())).ordinal as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_mem_alloc_desc_t),
            "::",
            stringify!(ordinal)
        )
    );
}
impl _ze_host_mem_alloc_flags_t {
    #[doc = "< host should cache allocation"]
    pub const ZE_HOST_MEM_ALLOC_FLAG_BIAS_CACHED: _ze_host_mem_alloc_flags_t =
        _ze_host_mem_alloc_flags_t(1);
}
impl _ze_host_mem_alloc_flags_t {
    #[doc = "< host should not cache allocation (UC)"]
    pub const ZE_HOST_MEM_ALLOC_FLAG_BIAS_UNCACHED: _ze_host_mem_alloc_flags_t =
        _ze_host_mem_alloc_flags_t(2);
}
impl _ze_host_mem_alloc_flags_t {
    #[doc = "< host memory should be allocated write-combined (WC)"]
    pub const ZE_HOST_MEM_ALLOC_FLAG_BIAS_WRITE_COMBINED: _ze_host_mem_alloc_flags_t =
        _ze_host_mem_alloc_flags_t(4);
}
impl _ze_host_mem_alloc_flags_t {
    pub const ZE_HOST_MEM_ALLOC_FLAG_FORCE_UINT32: _ze_host_mem_alloc_flags_t =
        _ze_host_mem_alloc_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_host_mem_alloc_flags_t> for _ze_host_mem_alloc_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_host_mem_alloc_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_host_mem_alloc_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_host_mem_alloc_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_host_mem_alloc_flags_t> for _ze_host_mem_alloc_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_host_mem_alloc_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_host_mem_alloc_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_host_mem_alloc_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported host memory allocation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_host_mem_alloc_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported host memory allocation flags"]
pub use self::_ze_host_mem_alloc_flags_t as ze_host_mem_alloc_flags_t;
#[doc = ""]
#[doc = " @brief Host memory allocation descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_host_mem_alloc_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] flags specifying additional allocation controls."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_host_mem_alloc_flags_t;"]
    #[doc = "< default behavior may use implicit driver-based heuristics."]
    pub flags: ze_host_mem_alloc_flags_t,
}
#[test]
fn bindgen_test_layout__ze_host_mem_alloc_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_host_mem_alloc_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_host_mem_alloc_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_host_mem_alloc_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_host_mem_alloc_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_host_mem_alloc_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_host_mem_alloc_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_host_mem_alloc_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_host_mem_alloc_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_host_mem_alloc_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_host_mem_alloc_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allocates shared memory on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Shared allocations share ownership between the host and one or more"]
    #[doc = "       devices."]
    #[doc = "     - Shared allocations may optionally be associated with a device by"]
    #[doc = "       passing a handle to the device."]
    #[doc = "     - Devices supporting only single-device shared access capabilities may"]
    #[doc = "       access shared memory associated with the device."]
    #[doc = "       For these devices, ownership of the allocation is shared between the"]
    #[doc = "       host and the associated device only."]
    #[doc = "     - Passing nullptr as the device handle does not associate the shared"]
    #[doc = "       allocation with any device."]
    #[doc = "       For allocations with no associated device, ownership of the allocation"]
    #[doc = "       is shared between the host and all devices supporting cross-device"]
    #[doc = "       shared access capabilities."]
    #[doc = "     - The application must only use the memory allocation for the context"]
    #[doc = "       and device, or its sub-devices, which was provided during allocation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == device_desc`"]
    #[doc = "         + `nullptr == host_desc`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < device_desc->flags`"]
    #[doc = "         + `0x7 < host_desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    #[doc = "         + Must be zero or a power-of-two"]
    #[doc = "         + `0 != (alignment & (alignment - 1))`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeMemAllocShared(
        hContext: ze_context_handle_t,
        device_desc: *const ze_device_mem_alloc_desc_t,
        host_desc: *const ze_host_mem_alloc_desc_t,
        size: usize,
        alignment: usize,
        hDevice: ze_device_handle_t,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allocates device memory on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Device allocations are owned by a specific device."]
    #[doc = "     - In general, a device allocation may only be accessed by the device"]
    #[doc = "       that owns it."]
    #[doc = "     - The application must only use the memory allocation for the context"]
    #[doc = "       and device, or its sub-devices, which was provided during allocation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == device_desc`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < device_desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    #[doc = "         + Must be zero or a power-of-two"]
    #[doc = "         + `0 != (alignment & (alignment - 1))`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeMemAllocDevice(
        hContext: ze_context_handle_t,
        device_desc: *const ze_device_mem_alloc_desc_t,
        size: usize,
        alignment: usize,
        hDevice: ze_device_handle_t,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allocates host memory on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Host allocations are owned by the host process."]
    #[doc = "     - Host allocations are accessible by the host and all devices within the"]
    #[doc = "       driver's context."]
    #[doc = "     - Host allocations are frequently used as staging areas to transfer data"]
    #[doc = "       to or from devices."]
    #[doc = "     - The application must only use the memory allocation for the context"]
    #[doc = "       which was provided during allocation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == host_desc`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x7 < host_desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    #[doc = "         + Must be zero or a power-of-two"]
    #[doc = "         + `0 != (alignment & (alignment - 1))`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeMemAllocHost(
        hContext: ze_context_handle_t,
        host_desc: *const ze_host_mem_alloc_desc_t,
        size: usize,
        alignment: usize,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Frees allocated host memory, device memory, or shared memory on the"]
    #[doc = "        context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the memory before it is freed"]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this memory"]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same pointer."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeMemFree(
        hContext: ze_context_handle_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
impl _ze_memory_type_t {
    #[doc = "< the memory pointed to is of unknown type"]
    pub const ZE_MEMORY_TYPE_UNKNOWN: _ze_memory_type_t = _ze_memory_type_t(0);
}
impl _ze_memory_type_t {
    #[doc = "< the memory pointed to is a host allocation"]
    pub const ZE_MEMORY_TYPE_HOST: _ze_memory_type_t = _ze_memory_type_t(1);
}
impl _ze_memory_type_t {
    #[doc = "< the memory pointed to is a device allocation"]
    pub const ZE_MEMORY_TYPE_DEVICE: _ze_memory_type_t = _ze_memory_type_t(2);
}
impl _ze_memory_type_t {
    #[doc = "< the memory pointed to is a shared ownership allocation"]
    pub const ZE_MEMORY_TYPE_SHARED: _ze_memory_type_t = _ze_memory_type_t(3);
}
impl _ze_memory_type_t {
    pub const ZE_MEMORY_TYPE_FORCE_UINT32: _ze_memory_type_t = _ze_memory_type_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Memory allocation type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_memory_type_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Memory allocation type"]
pub use self::_ze_memory_type_t as ze_memory_type_t;
#[doc = ""]
#[doc = " @brief Memory allocation properties queried using ::zeMemGetAllocProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_memory_allocation_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] type of allocated memory"]
    pub type_: ze_memory_type_t,
    #[doc = "< [out] identifier for this allocation"]
    pub id: u64,
    #[doc = "< [out] page size used for allocation"]
    pub pageSize: u64,
}
#[test]
fn bindgen_test_layout__ze_memory_allocation_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_memory_allocation_properties_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_memory_allocation_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_memory_allocation_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_memory_allocation_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).stype as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).type_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).id as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).pageSize as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(pageSize)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves attributes of a memory allocation"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The application may query attributes of a memory allocation unrelated"]
    #[doc = "       to the context."]
    #[doc = "       When this occurs, the returned allocation type will be"]
    #[doc = "       ::ZE_MEMORY_TYPE_UNKNOWN, and the returned identifier and associated"]
    #[doc = "       device is unspecified."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "         + `nullptr == pMemAllocProperties`"]
    pub fn zeMemGetAllocProperties(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        pMemAllocProperties: *mut ze_memory_allocation_properties_t,
        phDevice: *mut ze_device_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves the base address and/or size of an allocation"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeMemGetAddressRange(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        pBase: *mut *mut ::std::os::raw::c_void,
        pSize: *mut usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates an IPC memory handle for the specified allocation"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Takes a pointer to a device memory allocation and creates an IPC"]
    #[doc = "       memory handle for exporting it for use in another process."]
    #[doc = "     - The pointer must be base pointer of the device memory allocation; i.e."]
    #[doc = "       the value returned from ::zeMemAllocDevice."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "         + `nullptr == pIpcHandle`"]
    pub fn zeMemGetIpcHandle(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        pIpcHandle: *mut ze_ipc_mem_handle_t,
    ) -> ze_result_t;
}
impl _ze_ipc_memory_flags_t {
    #[doc = "< reserved for future use"]
    pub const ZE_IPC_MEMORY_FLAG_TBD: _ze_ipc_memory_flags_t = _ze_ipc_memory_flags_t(1);
}
impl _ze_ipc_memory_flags_t {
    pub const ZE_IPC_MEMORY_FLAG_FORCE_UINT32: _ze_ipc_memory_flags_t =
        _ze_ipc_memory_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_ipc_memory_flags_t> for _ze_ipc_memory_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_ipc_memory_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_ipc_memory_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_ipc_memory_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_ipc_memory_flags_t> for _ze_ipc_memory_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_ipc_memory_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_ipc_memory_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_ipc_memory_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported IPC memory flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_ipc_memory_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported IPC memory flags"]
pub use self::_ze_ipc_memory_flags_t as ze_ipc_memory_flags_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Opens an IPC memory handle to retrieve a device pointer on the"]
    #[doc = "        context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Takes an IPC memory handle from a remote process and associates it"]
    #[doc = "       with a device pointer usable in this process."]
    #[doc = "     - The device pointer in this process should not be freed with"]
    #[doc = "       ::zeMemFree, but rather with ::zeMemCloseIpcHandle."]
    #[doc = "     - Multiple calls to this function with the same IPC handle will return"]
    #[doc = "       unique pointers."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pptr`"]
    pub fn zeMemOpenIpcHandle(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        handle: ze_ipc_mem_handle_t,
        flags: ze_ipc_memory_flags_t,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Closes an IPC memory handle"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Closes an IPC memory handle by unmapping memory that was opened in"]
    #[doc = "       this process using ::zeMemOpenIpcHandle."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same pointer."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeMemCloseIpcHandle(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
    ) -> ze_result_t;
}
impl _ze_module_format_t {
    #[doc = "< Format is SPIRV IL format"]
    pub const ZE_MODULE_FORMAT_IL_SPIRV: _ze_module_format_t = _ze_module_format_t(0);
}
impl _ze_module_format_t {
    #[doc = "< Format is device native format"]
    pub const ZE_MODULE_FORMAT_NATIVE: _ze_module_format_t = _ze_module_format_t(1);
}
impl _ze_module_format_t {
    pub const ZE_MODULE_FORMAT_FORCE_UINT32: _ze_module_format_t = _ze_module_format_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported module creation input formats"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_module_format_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported module creation input formats"]
pub use self::_ze_module_format_t as ze_module_format_t;
#[doc = ""]
#[doc = " @brief Specialization constants - User defined constants"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_constants_t {
    #[doc = "< [in] Number of specialization constants."]
    pub numConstants: u32,
    #[doc = "< [in][range(0, numConstants)] Array of IDs that is sized to"]
    #[doc = "< numConstants."]
    pub pConstantIds: *const u32,
    #[doc = "< [in][range(0, numConstants)] Array of pointers to values that is sized"]
    #[doc = "< to numConstants."]
    pub pConstantValues: *mut *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_module_constants_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_constants_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_module_constants_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_constants_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_constants_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_constants_t>())).numConstants as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_constants_t),
            "::",
            stringify!(numConstants)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_constants_t>())).pConstantIds as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_constants_t),
            "::",
            stringify!(pConstantIds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_constants_t>())).pConstantValues as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_constants_t),
            "::",
            stringify!(pConstantValues)
        )
    );
}
#[doc = ""]
#[doc = " @brief Module descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] Module format passed in with pInputModule"]
    pub format: ze_module_format_t,
    #[doc = "< [in] size of input IL or ISA from pInputModule."]
    pub inputSize: usize,
    #[doc = "< [in] pointer to IL or ISA"]
    pub pInputModule: *const u8,
    #[doc = "< [in][optional] string containing compiler flags. Following options are supported."]
    #[doc = "<  - \"-ze-opt-disable\""]
    #[doc = "<       - Disable optimizations"]
    #[doc = "<  - \"-ze-opt-greater-than-4GB-buffer-required\""]
    #[doc = "<       - Use 64-bit offset calculations for buffers."]
    #[doc = "<  - \"-ze-opt-large-register-file\""]
    #[doc = "<       - Increase number of registers available to threads."]
    #[doc = "<  - \"-ze-opt-has-buffer-offset-arg\""]
    #[doc = "<       - Extend stateless to stateful optimization to more"]
    #[doc = "<         cases with the use of additional offset (e.g. 64-bit"]
    #[doc = "<         pointer to binding table with 32-bit offset)."]
    #[doc = "<  - \"-g\""]
    #[doc = "<       - Include debugging information."]
    pub pBuildFlags: *const ::std::os::raw::c_char,
    #[doc = "< [in][optional] pointer to specialization constants. Valid only for"]
    #[doc = "< SPIR-V input. This must be set to nullptr if no specialization"]
    #[doc = "< constants are provided."]
    pub pConstants: *const ze_module_constants_t,
}
#[test]
fn bindgen_test_layout__ze_module_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_desc_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ze_module_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).inputSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(inputSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).pInputModule as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(pInputModule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).pBuildFlags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(pBuildFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).pConstants as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(pConstants)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a module on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Compiles the module for execution on the device."]
    #[doc = "     - The application must only use the module for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The module can be copied to other devices and contexts within the same"]
    #[doc = "       driver instance by using ::zeModuleGetNativeBinary."]
    #[doc = "     - A build log can optionally be returned to the caller. The caller is"]
    #[doc = "       responsible for destroying build log using ::zeModuleBuildLogDestroy."]
    #[doc = "     - The module descriptor constants are only supported for SPIR-V"]
    #[doc = "       specialization constants."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == desc->pInputModule`"]
    #[doc = "         + `nullptr == phModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `::ZE_MODULE_FORMAT_NATIVE < desc->format`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NATIVE_BINARY"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `0 == desc->inputSize`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_MODULE_BUILD_FAILURE"]
    pub fn zeModuleCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *const ze_module_desc_t,
        phModule: *mut ze_module_handle_t,
        phBuildLog: *mut ze_module_build_log_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys module"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must destroy all kernel and build log handles created"]
    #[doc = "       from the module before destroying the module itself."]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the module before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this module."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same module handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeModuleDestroy(hModule: ze_module_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Dynamically link modules together that share import/export linkage"]
    #[doc = "        dependencies."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Modules support import and export linkage for functions and global"]
    #[doc = "       variables."]
    #[doc = "     - Modules that have imports can be dynamically linked to export modules"]
    #[doc = "       that satisfy those import requirements."]
    #[doc = "     - Modules can have both import and export linkages."]
    #[doc = "     - Modules that do not have any imports or exports do not need to be"]
    #[doc = "       linked."]
    #[doc = "     - Modules cannot be partially linked. All modules needed to satisfy all"]
    #[doc = "       import dependencies for a module must be passed in or"]
    #[doc = "       ::ZE_RESULT_ERROR_MODULE_LINK_FAILURE will returned."]
    #[doc = "     - Modules with imports need to be linked before kernel objects can be"]
    #[doc = "       created from them."]
    #[doc = "     - Modules will only be linked once. A module can be used in multiple"]
    #[doc = "       link calls if it has exports but it's imports will not be re-linked."]
    #[doc = "     - Ambiguous dependencies, where multiple modules satisfy the import"]
    #[doc = "       dependencies for another module, is not allowed."]
    #[doc = "     - ModuleGetNativeBinary can be called on any module regardless of"]
    #[doc = "       whether it is linked or not."]
    #[doc = "     - A link log can optionally be returned to the caller. The caller is"]
    #[doc = "       responsible for destroying build log using ::zeModuleBuildLogDestroy."]
    #[doc = "     - See SPIR-V specification for linkage details."]
    #[doc = "     - The application must ensure the modules being linked were created on"]
    #[doc = "       the same context."]
    #[doc = "     - The application may call this function from simultaneous threads as"]
    #[doc = "       long as the import modules being linked are not the same."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phModules`"]
    #[doc = "     - ::ZE_RESULT_ERROR_MODULE_LINK_FAILURE"]
    pub fn zeModuleDynamicLink(
        numModules: u32,
        phModules: *mut ze_module_handle_t,
        phLinkLog: *mut ze_module_build_log_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys module build log object"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The implementation of this function may immediately free all Host"]
    #[doc = "       allocations associated with this object."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same build log handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = "     - This function can be called before or after ::zeModuleDestroy for the"]
    #[doc = "       associated module."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModuleBuildLog`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeModuleBuildLogDestroy(hModuleBuildLog: ze_module_build_log_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves text string for build log."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The caller can pass nullptr for pBuildLog when querying only for size."]
    #[doc = "     - The caller must provide memory for build log."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModuleBuildLog`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pSize`"]
    pub fn zeModuleBuildLogGetString(
        hModuleBuildLog: ze_module_build_log_handle_t,
        pSize: *mut usize,
        pBuildLog: *mut ::std::os::raw::c_char,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve native binary from Module."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The native binary output can be cached to disk and new modules can be"]
    #[doc = "       later constructed from the cached copy."]
    #[doc = "     - The native binary will retain debugging information that is associated"]
    #[doc = "       with a module."]
    #[doc = "     - The caller can pass nullptr for pModuleNativeBinary when querying only"]
    #[doc = "       for size."]
    #[doc = "     - The implementation will copy the native binary into a buffer supplied"]
    #[doc = "       by the caller."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pSize`"]
    pub fn zeModuleGetNativeBinary(
        hModule: ze_module_handle_t,
        pSize: *mut usize,
        pModuleNativeBinary: *mut u8,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve global variable pointer from Module."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may query global pointer from any module that either"]
    #[doc = "       exports or imports it."]
    #[doc = "     - The application must dynamically link a module that imports a global"]
    #[doc = "       before the global pointer can be queried from it."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pGlobalName`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_GLOBAL_NAME"]
    pub fn zeModuleGetGlobalPointer(
        hModule: ze_module_handle_t,
        pGlobalName: *const ::std::os::raw::c_char,
        pSize: *mut usize,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve all kernel names in the module."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeModuleGetKernelNames(
        hModule: ze_module_handle_t,
        pCount: *mut u32,
        pNames: *mut *const ::std::os::raw::c_char,
    ) -> ze_result_t;
}
impl _ze_module_property_flags_t {
    #[doc = "< Module has imports (i.e. imported global variables and/or kernels)."]
    #[doc = "< See ::zeModuleDynamicLink."]
    pub const ZE_MODULE_PROPERTY_FLAG_IMPORTS: _ze_module_property_flags_t =
        _ze_module_property_flags_t(1);
}
impl _ze_module_property_flags_t {
    pub const ZE_MODULE_PROPERTY_FLAG_FORCE_UINT32: _ze_module_property_flags_t =
        _ze_module_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_module_property_flags_t> for _ze_module_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_module_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_module_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_module_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_module_property_flags_t> for _ze_module_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_module_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_module_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_module_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported module property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_module_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported module property flags"]
pub use self::_ze_module_property_flags_t as ze_module_property_flags_t;
#[doc = ""]
#[doc = " @brief Module properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of ::ze_module_property_flags_t"]
    pub flags: ze_module_property_flags_t,
}
#[test]
fn bindgen_test_layout__ze_module_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_module_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_properties_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_properties_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_properties_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_properties_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve module properties."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pModuleProperties`"]
    pub fn zeModuleGetProperties(
        hModule: ze_module_handle_t,
        pModuleProperties: *mut ze_module_properties_t,
    ) -> ze_result_t;
}
impl _ze_kernel_flags_t {
    #[doc = "< force all device allocations to be resident during execution"]
    pub const ZE_KERNEL_FLAG_FORCE_RESIDENCY: _ze_kernel_flags_t = _ze_kernel_flags_t(1);
}
impl _ze_kernel_flags_t {
    #[doc = "< application is responsible for all residency of device allocations."]
    #[doc = "< driver may disable implicit residency management."]
    pub const ZE_KERNEL_FLAG_EXPLICIT_RESIDENCY: _ze_kernel_flags_t = _ze_kernel_flags_t(2);
}
impl _ze_kernel_flags_t {
    pub const ZE_KERNEL_FLAG_FORCE_UINT32: _ze_kernel_flags_t = _ze_kernel_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_kernel_flags_t> for _ze_kernel_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_kernel_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_kernel_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_kernel_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_kernel_flags_t> for _ze_kernel_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_kernel_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_kernel_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_kernel_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported kernel creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_kernel_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported kernel creation flags"]
pub use self::_ze_kernel_flags_t as ze_kernel_flags_t;
#[doc = ""]
#[doc = " @brief Kernel descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_kernel_flags_t;"]
    #[doc = "< default behavior may use driver-based residency."]
    pub flags: ze_kernel_flags_t,
    #[doc = "< [in] null-terminated name of kernel in module"]
    pub pKernelName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__ze_kernel_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_desc_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_kernel_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_desc_t>())).pKernelName as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_desc_t),
            "::",
            stringify!(pKernelName)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Create a kernel from the module."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Modules that have unresolved imports need to be dynamically linked"]
    #[doc = "       before a kernel can be created from them. (See ::zeModuleDynamicLink)"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == desc->pKernelName`"]
    #[doc = "         + `nullptr == phKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_KERNEL_NAME"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_MODULE_UNLINKED"]
    pub fn zeKernelCreate(
        hModule: ze_module_handle_t,
        desc: *const ze_kernel_desc_t,
        phKernel: *mut ze_kernel_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a kernel object"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the kernel before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this kernel."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeKernelDestroy(hKernel: ze_kernel_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve a function pointer from a module by name"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The function pointer is unique for the device on which the module was"]
    #[doc = "       created."]
    #[doc = "     - The function pointer is no longer valid if module is destroyed."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pFunctionName`"]
    #[doc = "         + `nullptr == pfnFunction`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_FUNCTION_NAME"]
    pub fn zeModuleGetFunctionPointer(
        hModule: ze_module_handle_t,
        pFunctionName: *const ::std::os::raw::c_char,
        pfnFunction: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Set group size for a kernel on the current Host thread."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The group size will be used when a ::zeCommandListAppendLaunchKernel"]
    #[doc = "       variant is called."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION"]
    pub fn zeKernelSetGroupSize(
        hKernel: ze_kernel_handle_t,
        groupSizeX: u32,
        groupSizeY: u32,
        groupSizeZ: u32,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Query a suggested group size for a kernel given a global size for each"]
    #[doc = "        dimension."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This function ignores the group size that is set using"]
    #[doc = "       ::zeKernelSetGroupSize."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == groupSizeX`"]
    #[doc = "         + `nullptr == groupSizeY`"]
    #[doc = "         + `nullptr == groupSizeZ`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION"]
    pub fn zeKernelSuggestGroupSize(
        hKernel: ze_kernel_handle_t,
        globalSizeX: u32,
        globalSizeY: u32,
        globalSizeZ: u32,
        groupSizeX: *mut u32,
        groupSizeY: *mut u32,
        groupSizeZ: *mut u32,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Query a suggested max group count for a cooperative kernel."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == totalGroupCount`"]
    pub fn zeKernelSuggestMaxCooperativeGroupCount(
        hKernel: ze_kernel_handle_t,
        totalGroupCount: *mut u32,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Set kernel argument for a kernel on the current Host thread."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The argument values will be used when a"]
    #[doc = "       ::zeCommandListAppendLaunchKernel variant is called."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE"]
    pub fn zeKernelSetArgumentValue(
        hKernel: ze_kernel_handle_t,
        argIndex: u32,
        argSize: usize,
        pArgValue: *const ::std::os::raw::c_void,
    ) -> ze_result_t;
}
impl _ze_kernel_indirect_access_flags_t {
    #[doc = "< Indicates that the kernel accesses host allocations indirectly."]
    pub const ZE_KERNEL_INDIRECT_ACCESS_FLAG_HOST: _ze_kernel_indirect_access_flags_t =
        _ze_kernel_indirect_access_flags_t(1);
}
impl _ze_kernel_indirect_access_flags_t {
    #[doc = "< Indicates that the kernel accesses device allocations indirectly."]
    pub const ZE_KERNEL_INDIRECT_ACCESS_FLAG_DEVICE: _ze_kernel_indirect_access_flags_t =
        _ze_kernel_indirect_access_flags_t(2);
}
impl _ze_kernel_indirect_access_flags_t {
    #[doc = "< Indicates that the kernel accesses shared allocations indirectly."]
    pub const ZE_KERNEL_INDIRECT_ACCESS_FLAG_SHARED: _ze_kernel_indirect_access_flags_t =
        _ze_kernel_indirect_access_flags_t(4);
}
impl _ze_kernel_indirect_access_flags_t {
    pub const ZE_KERNEL_INDIRECT_ACCESS_FLAG_FORCE_UINT32: _ze_kernel_indirect_access_flags_t =
        _ze_kernel_indirect_access_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_kernel_indirect_access_flags_t> for _ze_kernel_indirect_access_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_kernel_indirect_access_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_kernel_indirect_access_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_kernel_indirect_access_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_kernel_indirect_access_flags_t> for _ze_kernel_indirect_access_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_kernel_indirect_access_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_kernel_indirect_access_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_kernel_indirect_access_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Kernel indirect access flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_kernel_indirect_access_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Kernel indirect access flags"]
pub use self::_ze_kernel_indirect_access_flags_t as ze_kernel_indirect_access_flags_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Sets kernel indirect access flags."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application should specify which allocations will be indirectly"]
    #[doc = "       accessed by the kernel to allow driver to optimize which allocations"]
    #[doc = "       are made resident"]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same Kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x7 < flags`"]
    pub fn zeKernelSetIndirectAccess(
        hKernel: ze_kernel_handle_t,
        flags: ze_kernel_indirect_access_flags_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve kernel indirect access flags."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This function may be called from simultaneous threads with the same"]
    #[doc = "       Kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pFlags`"]
    pub fn zeKernelGetIndirectAccess(
        hKernel: ze_kernel_handle_t,
        pFlags: *mut ze_kernel_indirect_access_flags_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve all declared kernel attributes (i.e. can be specified with"]
    #[doc = "        __attribute__ in runtime language)."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This function may be called from simultaneous threads with the same"]
    #[doc = "       Kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pSize`"]
    #[doc = "         + `nullptr == pString`"]
    pub fn zeKernelGetSourceAttributes(
        hKernel: ze_kernel_handle_t,
        pSize: *mut u32,
        pString: *mut *mut ::std::os::raw::c_char,
    ) -> ze_result_t;
}
impl _ze_cache_config_flags_t {
    #[doc = "< Large SLM size"]
    pub const ZE_CACHE_CONFIG_FLAG_LARGE_SLM: _ze_cache_config_flags_t =
        _ze_cache_config_flags_t(1);
}
impl _ze_cache_config_flags_t {
    #[doc = "< Large General Data size"]
    pub const ZE_CACHE_CONFIG_FLAG_LARGE_DATA: _ze_cache_config_flags_t =
        _ze_cache_config_flags_t(2);
}
impl _ze_cache_config_flags_t {
    pub const ZE_CACHE_CONFIG_FLAG_FORCE_UINT32: _ze_cache_config_flags_t =
        _ze_cache_config_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_cache_config_flags_t> for _ze_cache_config_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_cache_config_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_cache_config_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_cache_config_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_cache_config_flags_t> for _ze_cache_config_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_cache_config_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_cache_config_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_cache_config_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported Cache Config flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_cache_config_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported Cache Config flags"]
pub use self::_ze_cache_config_flags_t as ze_cache_config_flags_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Sets the preferred cache configuration for a kernel on the current"]
    #[doc = "        Host thread."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The cache configuration will be used when a"]
    #[doc = "       ::zeCommandListAppendLaunchKernel variant is called."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_FEATURE"]
    pub fn zeKernelSetCacheConfig(
        hKernel: ze_kernel_handle_t,
        flags: ze_cache_config_flags_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Kernel universal unique id (UUID)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_uuid_t {
    #[doc = "< [out] opaque data representing a kernel UUID"]
    pub kid: [u8; 16usize],
    #[doc = "< [out] opaque data representing the kernel's module UUID"]
    pub mid: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__ze_kernel_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_uuid_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_kernel_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_kernel_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_uuid_t>())).kid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_uuid_t),
            "::",
            stringify!(kid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_uuid_t>())).mid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_uuid_t),
            "::",
            stringify!(mid)
        )
    );
}
#[doc = ""]
#[doc = " @brief Kernel properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] number of kernel arguments."]
    pub numKernelArgs: u32,
    #[doc = "< [out] required group size in the X dimension,"]
    #[doc = "< or zero if there is no required group size"]
    pub requiredGroupSizeX: u32,
    #[doc = "< [out] required group size in the Y dimension,"]
    #[doc = "< or zero if there is no required group size"]
    pub requiredGroupSizeY: u32,
    #[doc = "< [out] required group size in the Z dimension,"]
    #[doc = "< or zero if there is no required group size"]
    pub requiredGroupSizeZ: u32,
    #[doc = "< [out] required number of subgroups per thread group,"]
    #[doc = "< or zero if there is no required number of subgroups"]
    pub requiredNumSubGroups: u32,
    #[doc = "< [out] required subgroup size,"]
    #[doc = "< or zero if there is no required subgroup size"]
    pub requiredSubgroupSize: u32,
    #[doc = "< [out] maximum subgroup size"]
    pub maxSubgroupSize: u32,
    #[doc = "< [out] maximum number of subgroups per thread group"]
    pub maxNumSubgroups: u32,
    #[doc = "< [out] local memory size used by each thread group"]
    pub localMemSize: u32,
    #[doc = "< [out] private memory size allocated by compiler used by each thread"]
    pub privateMemSize: u32,
    #[doc = "< [out] spill memory size allocated by compiler"]
    pub spillMemSize: u32,
    #[doc = "< [out] universal unique identifier."]
    pub uuid: ze_kernel_uuid_t,
}
#[test]
fn bindgen_test_layout__ze_kernel_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_properties_t>(),
        96usize,
        concat!("Size of: ", stringify!(_ze_kernel_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_properties_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_properties_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).numKernelArgs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(numKernelArgs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredGroupSizeX as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredGroupSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredGroupSizeY as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredGroupSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredGroupSizeZ as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredGroupSizeZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredNumSubGroups as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredNumSubGroups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredSubgroupSize as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredSubgroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).maxSubgroupSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(maxSubgroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).maxNumSubgroups as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(maxNumSubgroups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).localMemSize as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(localMemSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).privateMemSize as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(privateMemSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).spillMemSize as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(spillMemSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_properties_t>())).uuid as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(uuid)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve kernel properties."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pKernelProperties`"]
    pub fn zeKernelGetProperties(
        hKernel: ze_kernel_handle_t,
        pKernelProperties: *mut ze_kernel_properties_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve kernel name from Kernel."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The caller can pass nullptr for pName when querying only for size."]
    #[doc = "     - The implementation will copy the kernel name into a buffer supplied by"]
    #[doc = "       the caller."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pSize`"]
    pub fn zeKernelGetName(
        hKernel: ze_kernel_handle_t,
        pSize: *mut usize,
        pName: *mut ::std::os::raw::c_char,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Kernel dispatch group count."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_group_count_t {
    #[doc = "< [in] number of thread groups in X dimension"]
    pub groupCountX: u32,
    #[doc = "< [in] number of thread groups in Y dimension"]
    pub groupCountY: u32,
    #[doc = "< [in] number of thread groups in Z dimension"]
    pub groupCountZ: u32,
}
#[test]
fn bindgen_test_layout__ze_group_count_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_group_count_t>(),
        12usize,
        concat!("Size of: ", stringify!(_ze_group_count_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_group_count_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_group_count_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_group_count_t>())).groupCountX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_group_count_t),
            "::",
            stringify!(groupCountX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_group_count_t>())).groupCountY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_group_count_t),
            "::",
            stringify!(groupCountY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_group_count_t>())).groupCountZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_group_count_t),
            "::",
            stringify!(groupCountZ)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch kernel over one or more work groups."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the kernel and events are accessible by"]
    #[doc = "       the device on which the command list was created."]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - The application must ensure the command list, kernel and events were"]
    #[doc = "       created on the same context."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pLaunchFuncArgs`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendLaunchKernel(
        hCommandList: ze_command_list_handle_t,
        hKernel: ze_kernel_handle_t,
        pLaunchFuncArgs: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch kernel cooperatively over one or more work groups."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the kernel and events are accessible by"]
    #[doc = "       the device on which the command list was created."]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - This may only be used for a command list that are submitted to command"]
    #[doc = "       queue with cooperative flag set."]
    #[doc = "     - The application must ensure the command list, kernel and events were"]
    #[doc = "       created on the same context."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = "     - Use ::zeKernelSuggestMaxCooperativeGroupCount to recommend max group"]
    #[doc = "       count for device for cooperative functions that device supports."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pLaunchFuncArgs`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendLaunchCooperativeKernel(
        hCommandList: ze_command_list_handle_t,
        hKernel: ze_kernel_handle_t,
        pLaunchFuncArgs: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch kernel over one or more work groups using indirect arguments."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the kernel and events are accessible by"]
    #[doc = "       the device on which the command list was created."]
    #[doc = "     - The application must ensure the launch arguments are visible to the"]
    #[doc = "       device on which the command list was created."]
    #[doc = "     - The implementation must not access the contents of the launch"]
    #[doc = "       arguments as they are free to be modified by either the Host or device"]
    #[doc = "       up until execution."]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - The application must ensure the command list, kernel and events were"]
    #[doc = "       created, and the memory was allocated, on the same context."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pLaunchArgumentsBuffer`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendLaunchKernelIndirect(
        hCommandList: ze_command_list_handle_t,
        hKernel: ze_kernel_handle_t,
        pLaunchArgumentsBuffer: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch multiple kernels over one or more work groups using an array of"]
    #[doc = "        indirect arguments."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the kernel and events are accessible by"]
    #[doc = "       the device on which the command list was created."]
    #[doc = "     - The application must ensure the array of launch arguments and count"]
    #[doc = "       buffer are visible to the device on which the command list was"]
    #[doc = "       created."]
    #[doc = "     - The implementation must not access the contents of the array of launch"]
    #[doc = "       arguments or count buffer as they are free to be modified by either"]
    #[doc = "       the Host or device up until execution."]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - The application must enusre the command list, kernel and events were"]
    #[doc = "       created, and the memory was allocated, on the same context."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phKernels`"]
    #[doc = "         + `nullptr == pCountBuffer`"]
    #[doc = "         + `nullptr == pLaunchArgumentsBuffer`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendLaunchMultipleKernelsIndirect(
        hCommandList: ze_command_list_handle_t,
        numKernels: u32,
        phKernels: *mut ze_kernel_handle_t,
        pCountBuffer: *const u32,
        pLaunchArgumentsBuffer: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Makes memory resident for the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory is resident before being"]
    #[doc = "       referenced by the device"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeContextMakeMemoryResident(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allows memory to be evicted from the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the memory before it is evicted"]
    #[doc = "     - The application may free the memory without evicting; the memory is"]
    #[doc = "       implicitly evicted when freed."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeContextEvictMemory(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Makes image resident for the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the image is resident before being"]
    #[doc = "       referenced by the device"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeContextMakeImageResident(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        hImage: ze_image_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allows image to be evicted from the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the image before it is evicted"]
    #[doc = "     - The application may destroy the image without evicting; the image is"]
    #[doc = "       implicitly evicted when destroyed."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeContextEvictImage(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        hImage: ze_image_handle_t,
    ) -> ze_result_t;
}
impl _ze_sampler_address_mode_t {
    #[doc = "< No coordinate modifications for out-of-bounds image access."]
    pub const ZE_SAMPLER_ADDRESS_MODE_NONE: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(0);
}
impl _ze_sampler_address_mode_t {
    #[doc = "< Out-of-bounds coordinates are wrapped back around."]
    pub const ZE_SAMPLER_ADDRESS_MODE_REPEAT: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(1);
}
impl _ze_sampler_address_mode_t {
    #[doc = "< Out-of-bounds coordinates are clamped to edge."]
    pub const ZE_SAMPLER_ADDRESS_MODE_CLAMP: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(2);
}
impl _ze_sampler_address_mode_t {
    #[doc = "< Out-of-bounds coordinates are clamped to border color which is (0.0f,"]
    #[doc = "< 0.0f, 0.0f, 0.0f) if image format swizzle contains alpha, otherwise"]
    #[doc = "< (0.0f, 0.0f, 0.0f, 1.0f)."]
    pub const ZE_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(3);
}
impl _ze_sampler_address_mode_t {
    #[doc = "< Out-of-bounds coordinates are mirrored starting from edge."]
    pub const ZE_SAMPLER_ADDRESS_MODE_MIRROR: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(4);
}
impl _ze_sampler_address_mode_t {
    pub const ZE_SAMPLER_ADDRESS_MODE_FORCE_UINT32: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Sampler addressing modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_sampler_address_mode_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Sampler addressing modes"]
pub use self::_ze_sampler_address_mode_t as ze_sampler_address_mode_t;
impl _ze_sampler_filter_mode_t {
    #[doc = "< No coordinate modifications for out of bounds image access."]
    pub const ZE_SAMPLER_FILTER_MODE_NEAREST: _ze_sampler_filter_mode_t =
        _ze_sampler_filter_mode_t(0);
}
impl _ze_sampler_filter_mode_t {
    #[doc = "< Out-of-bounds coordinates are wrapped back around."]
    pub const ZE_SAMPLER_FILTER_MODE_LINEAR: _ze_sampler_filter_mode_t =
        _ze_sampler_filter_mode_t(1);
}
impl _ze_sampler_filter_mode_t {
    pub const ZE_SAMPLER_FILTER_MODE_FORCE_UINT32: _ze_sampler_filter_mode_t =
        _ze_sampler_filter_mode_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Sampler filtering modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_sampler_filter_mode_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Sampler filtering modes"]
pub use self::_ze_sampler_filter_mode_t as ze_sampler_filter_mode_t;
#[doc = ""]
#[doc = " @brief Sampler descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_sampler_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] Sampler addressing mode to determine how out-of-bounds"]
    #[doc = "< coordinates are handled."]
    pub addressMode: ze_sampler_address_mode_t,
    #[doc = "< [in] Sampler filter mode to determine how samples are filtered."]
    pub filterMode: ze_sampler_filter_mode_t,
    #[doc = "< [in] Are coordinates normalized [0, 1] or not."]
    pub isNormalized: ze_bool_t,
}
#[test]
fn bindgen_test_layout__ze_sampler_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_sampler_desc_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_sampler_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_sampler_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_sampler_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).addressMode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).filterMode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).isNormalized as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(isNormalized)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates sampler on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the sampler for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phSampler`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `::ZE_SAMPLER_ADDRESS_MODE_MIRROR < desc->addressMode`"]
    #[doc = "         + `::ZE_SAMPLER_FILTER_MODE_LINEAR < desc->filterMode`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    pub fn zeSamplerCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *const ze_sampler_desc_t,
        phSampler: *mut ze_sampler_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys sampler object"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the sampler before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this sampler."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same sampler handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hSampler`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeSamplerDestroy(hSampler: ze_sampler_handle_t) -> ze_result_t;
}
impl _ze_memory_access_attribute_t {
    #[doc = "< Indicates the memory page is inaccessible."]
    pub const ZE_MEMORY_ACCESS_ATTRIBUTE_NONE: _ze_memory_access_attribute_t =
        _ze_memory_access_attribute_t(0);
}
impl _ze_memory_access_attribute_t {
    #[doc = "< Indicates the memory page supports read write access."]
    pub const ZE_MEMORY_ACCESS_ATTRIBUTE_READWRITE: _ze_memory_access_attribute_t =
        _ze_memory_access_attribute_t(1);
}
impl _ze_memory_access_attribute_t {
    #[doc = "< Indicates the memory page supports read-only access."]
    pub const ZE_MEMORY_ACCESS_ATTRIBUTE_READONLY: _ze_memory_access_attribute_t =
        _ze_memory_access_attribute_t(2);
}
impl _ze_memory_access_attribute_t {
    pub const ZE_MEMORY_ACCESS_ATTRIBUTE_FORCE_UINT32: _ze_memory_access_attribute_t =
        _ze_memory_access_attribute_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Virtual memory page access attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_memory_access_attribute_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Virtual memory page access attributes"]
pub use self::_ze_memory_access_attribute_t as ze_memory_access_attribute_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Reserves pages in virtual address space."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the memory allocation on the context for"]
    #[doc = "       which it was created."]
    #[doc = "     - The starting address and size must be page aligned. See"]
    #[doc = "       ::zeVirtualMemQueryPageSize."]
    #[doc = "     - If pStart is not null then implementation will attempt to reserve"]
    #[doc = "       starting from that address. If not available then will find another"]
    #[doc = "       suitable starting address."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The access attributes will default to none to indicate reservation is"]
    #[doc = "       inaccessible."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pStart`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeVirtualMemReserve(
        hContext: ze_context_handle_t,
        pStart: *const ::std::os::raw::c_void,
        size: usize,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Free pages in a reserved virtual address range."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Any existing virtual mappings for the range will be unmapped."]
    #[doc = "     - Physical allocations objects that were mapped to this range will not"]
    #[doc = "       be destroyed. These need to be destroyed explicitly."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    pub fn zeVirtualMemFree(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries page size to use for aligning virtual memory reservations and"]
    #[doc = "        physical memory allocations."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pagesize`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    pub fn zeVirtualMemQueryPageSize(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        size: usize,
        pagesize: *mut usize,
    ) -> ze_result_t;
}
impl _ze_physical_mem_flags_t {
    #[doc = "< reserved for future use."]
    pub const ZE_PHYSICAL_MEM_FLAG_TBD: _ze_physical_mem_flags_t = _ze_physical_mem_flags_t(1);
}
impl _ze_physical_mem_flags_t {
    pub const ZE_PHYSICAL_MEM_FLAG_FORCE_UINT32: _ze_physical_mem_flags_t =
        _ze_physical_mem_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_physical_mem_flags_t> for _ze_physical_mem_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_physical_mem_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_physical_mem_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_physical_mem_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_physical_mem_flags_t> for _ze_physical_mem_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_physical_mem_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_physical_mem_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_physical_mem_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported physical memory creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_physical_mem_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported physical memory creation flags"]
pub use self::_ze_physical_mem_flags_t as ze_physical_mem_flags_t;
#[doc = ""]
#[doc = " @brief Physical memory descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_physical_mem_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_physical_mem_flags_t."]
    pub flags: ze_physical_mem_flags_t,
    #[doc = "< [in] size in bytes to reserve; must be page aligned."]
    pub size: usize,
}
#[test]
fn bindgen_test_layout__ze_physical_mem_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_physical_mem_desc_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_physical_mem_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_physical_mem_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_physical_mem_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_physical_mem_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_physical_mem_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_physical_mem_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_physical_mem_desc_t>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_desc_t),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a physical memory object for the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the physical memory object on the"]
    #[doc = "       context for which it was created."]
    #[doc = "     - The size must be page aligned. See ::zeVirtualMemQueryPageSize."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phPhysicalMemory`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == desc->size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    pub fn zePhysicalMemCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *mut ze_physical_mem_desc_t,
        phPhysicalMemory: *mut ze_physical_mem_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a physical memory object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the physical memory object before it is deleted"]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same physical memory handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hPhysicalMemory`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zePhysicalMemDestroy(
        hContext: ze_context_handle_t,
        hPhysicalMemory: ze_physical_mem_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Maps pages in virtual address space to pages from physical memory"]
    #[doc = "        object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The virtual address range must have been reserved using"]
    #[doc = "       ::zeVirtualMemReserve."]
    #[doc = "     - The application must only use the mapped memory allocation on the"]
    #[doc = "       context for which it was created."]
    #[doc = "     - The virtual start address and size must be page aligned. See"]
    #[doc = "       ::zeVirtualMemQueryPageSize."]
    #[doc = "     - The application should use, for the starting address and size, the"]
    #[doc = "       same size alignment used for the physical allocation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hPhysicalMemory`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `::ZE_MEMORY_ACCESS_ATTRIBUTE_READONLY < access`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    pub fn zeVirtualMemMap(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        hPhysicalMemory: ze_physical_mem_handle_t,
        offset: usize,
        access: ze_memory_access_attribute_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Unmaps pages in virtual address space from pages from a physical"]
    #[doc = "        memory object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The page access attributes for virtual address range will revert back"]
    #[doc = "       to none."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT - \"Address must be page aligned\""]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "         + Size must be page aligned"]
    pub fn zeVirtualMemUnmap(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Set memory access attributes for a virtual address range."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This function may be called from simultaneous threads with the same"]
    #[doc = "       function handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `::ZE_MEMORY_ACCESS_ATTRIBUTE_READONLY < access`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT - \"Address must be page aligned\""]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "         + Size must be page aligned"]
    pub fn zeVirtualMemSetAccessAttribute(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        access: ze_memory_access_attribute_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Get memory access attribute for a virtual address range."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - If size and outSize are equal then the pages in the specified virtual"]
    #[doc = "       address range have the same access attributes."]
    #[doc = "     - This function may be called from simultaneous threads with the same"]
    #[doc = "       function handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "         + `nullptr == access`"]
    #[doc = "         + `nullptr == outSize`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT - \"Address must be page aligned\""]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "         + Size must be page aligned"]
    pub fn zeVirtualMemGetAccessAttribute(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        access: *mut ze_memory_access_attribute_t,
        outSize: *mut usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Set global work offset for a kernel on the current Host thread."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The global work offset will be used when"]
    #[doc = "       a\u{a0}::zeCommandListAppendLaunchKernel()\u{a0}variant is called."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    pub fn zeKernelSetGlobalOffsetExp(
        hKernel: ze_kernel_handle_t,
        offsetX: u32,
        offsetY: u32,
        offsetZ: u32,
    ) -> ze_result_t;
}
